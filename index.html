# -001
<!-- Patched version with described fixes applied (placeholder) -->

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ä¸€æ¬¡é–¢æ•°ãƒˆãƒ©ãƒ³ãƒ— v40ï¼ˆæ”¹è‰¯ç‰ˆï¼‰</title>
<style>
  /* åŸºæœ¬ãƒ‡ã‚¶ã‚¤ãƒ³ï¼ˆå…ƒã‚’å°Šé‡ã—ã¤ã¤è¦–èªæ€§å‘ä¸Šï¼‰ */
  :root{
    --bg1:#001428; --bg2:#00263e; --panel:#021a2d; --accent:#ffd966;
  }
  html,body{height:100%; margin:0; font-family:"Segoe UI",sans-serif; background:linear-gradient(var(--bg1),var(--bg2)); color:#fff;}
  h1{font-size:40px; font-weight:800; text-align:center; margin:28px 0;}
  .container-box{background:var(--panel); padding:20px 26px; border-radius:14px; max-width: 90%; width: auto; box-shadow:0 0 8px #0007; margin:0 auto;}
  button{padding:8px 10px;border-radius:6px;border:none;cursor:pointer;background:#fff;color:#000;}
  input[type=number]{padding:6px;border-radius:6px;border:none;width:80px;}
  /* game area */
  #gameArea{display:flex;gap:32px;padding:24px;}
  #cardArea{flex:1; min-height:420px;}
  .card-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:12px;margin-top:18px;}
  .card{perspective:800px; cursor:pointer; position:relative;}
  .card-inner{transition: transform .45s; transform-style: preserve-3d; position:relative; width:100%; min-height:90px; border-radius:10px;}
  .face{backface-visibility:hidden; position:absolute; left:0; top:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; padding:8px; border-radius:10px;}
  .front{background:#072033; font-size:22px;}
  .back{background:#0c2a3d; transform:rotateY(180deg); overflow:auto; color:#fff; font-size:14px;}
  .card.flipped .card-inner{transform:rotateY(180deg);}
  .card.matched{opacity:0.45; pointer-events:none;}
  /* table inside card - æ¨ªå‘ãè¡¨ç¤ºç”¨ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ */
  .table-card table{border-collapse:collapse; width:100%; table-layout: fixed;}
  .table-card td,.table-card th{padding:4px; border:1px solid rgba(255,255,255,0.06); font-size:13px; text-align:center;}
  /* baba UI circle */
  .baba-container{display:flex;flex-direction:column;align-items:center;gap:14px}
  .circle-wrap{position:relative;width:560px;height:420px;}
  .player-slot{position:absolute; width:120px; text-align:center; transform-origin:center center;}
  .player-slot .slot-panel{background:rgba(2,40,50,0.85); padding:8px;border-radius:10px;}
  .player-slot.current .slot-panel{box-shadow:0 0 18px var(--accent); border:2px solid rgba(255,217,102,0.2);}
  .player-slot .draw-btn{margin-top:8px;padding:6px;border-radius:6px;background:#fff;color:#000;cursor:pointer;}
  .hand-row{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding-top:8px;}
  .hand-card{background:#06313f;padding:8px;border-radius:8px;min-width:80px;min-height:50px;display:flex;align-items:center;justify-content:center;text-align:center;cursor:default;}
  .hand-card.selectable{cursor:pointer; outline:none;}
  .hand-card.selected{outline:3px solid #ffd966;}
  /* info modal / graph modal / result modal */
  .modal-back{display:none; position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:100; align-items:center; justify-content:center;}
  .modal{background:#fff;color:#000;border-radius:10px;padding:14px; max-height:90vh; overflow:auto;}
  #graphModal .modal{width:80vw; max-width:1100px; height:80vh;}
  #matchModal .modal{width:640px;}
  #resultModal .modal{width:720px;}
  .tab-buttons{display:flex;gap:6px;margin-bottom:8px;}
  .tab-buttons button{background:#eee;color:#000;padding:6px 8px;border-radius:6px;border:none;cursor:pointer;}
  .tab-content{background:#fff;padding:8px;border-radius:6px;min-height:160px;}
  /* turn banner */
  #turnBanner{font-size:22px;font-weight:800;margin-bottom:16px;display:flex;align-items:center;gap:8px;}
  .turn-badge{background:var(--panel); padding:6px 10px;border-radius:10px;}
  /* learned list */
  #learnedList{padding-left:6px;font-size:15px;max-height:360px;overflow:auto;}
  /* small utilities */
  .small{font-size:13px;opacity:0.9;}
  .float-right{text-align:right;}

  /* ãƒ¢ãƒã‚¤ãƒ«å‘ã‘å¯¾å¿œ */
  @media screen and (max-width: 768px) {
    h1{ font-size: 28px; margin: 18px 0; }
    .container-box{ max-width: 95%; padding: 16px; }

    /* ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ã‚’ç¸¦ä¸¦ã³ã«å¤‰æ›´ */
    #gameArea{
      flex-direction: column; 
      gap: 16px;
      padding: 8px;
    }
    /* å­¦ç¿’å±¥æ­´ã‚’ã‚«ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ã®ä¸‹ã«é…ç½® */
    #gameArea > div:nth-child(2) {
      width: 100% !important; /* å¹…ã‚’ãƒ•ãƒ«ã«ã™ã‚‹ */
    }
    
    /* ãƒãƒæŠœãUIã®å††å½¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’èª¿æ•´ */
    .circle-wrap{
      width: 100%; 
      height: 360px; 
    }
    .player-slot{
      width: 100px; /* ã‚¹ãƒ­ãƒƒãƒˆå¹…ã‚’èª¿æ•´ */
    }
    .baba-container{
      display: block; 
    }
    
    /* ä¸­å¤®ã®æ‰‹æœ­ã‚’èª¿æ•´ */
    .hand-card{
      min-width: 60px;
      min-height: 40px;
      font-size: 12px;
      padding: 4px;
    }

    /* ãƒ¢ãƒ¼ãƒ€ãƒ«ã®èª¿æ•´ */
    #graphModal .modal{
      width: 95vw; 
      max-width: 95vw;
      height: 90vh;
      margin: 10px;
    }
    #matchModal .modal{
      width: 90vw;
    }
    #resultModal .modal{
      width: 90vw;
    }
  }
</style>
</head>
<body>

<h1>ä¸€æ¬¡é–¢æ•°ãƒˆãƒ©ãƒ³ãƒ— v40ï¼ˆæ”¹è‰¯ç‰ˆï¼‰</h1>

<div id="homeScreen" style="display:flex;flex-direction:column;align-items:center;margin-top:10px;">
  <div class="container-box">
    <div style="font-size:20px;font-weight:700;margin-bottom:6px;">ãƒ¢ãƒ¼ãƒ‰ãƒ»ãƒšã‚¢æ•°ãƒ»CPUå¼·ã•ã‚’é¸ã‚“ã§ â–¶ ã‚²ãƒ¼ãƒ é–‹å§‹</div>
    <div style="margin-top:12px;">
      <div style="font-size:18px;font-weight:700;">ãƒ¢ãƒ¼ãƒ‰</div>
      <button id="modeMemoryBtn" onclick="selectMode('memory')" style="margin-right:8px;">ğŸ§  ç¥çµŒè¡°å¼±</button>
      <button id="modeBabaBtn" onclick="selectMode('babanuki')">ğŸƒ ãƒãƒæŠœã</button>
    </div>
    <div style="margin-top:16px;">
      <div style="font-size:18px;font-weight:700;">ãƒšã‚¢æ•°ï¼ˆ3ã€œ10ï¼‰</div>
      <input id="pairInput" type="number" min="3" max="10" value="4" />
    </div>
    <div style="margin-top:16px;">
      <div style="font-size:18px;font-weight:700;">CPU ã®å¼·ã•</div>
      <button id="cpuWeak" onclick="setCPU('weak')">å¼±</button>
      <button id="cpuNormal" onclick="setCPU('normal')" style="margin-left:6px;">æ™®é€š</button>
      <button id="cpuStrong" onclick="setCPU('strong')" style="margin-left:6px;">å¼·</button>
    </div>
    <div style="margin-top:22px;">
      <button onclick="startGameFromHome()">â–¶ ã‚²ãƒ¼ãƒ é–‹å§‹</button>
      <button onclick="openSetup()" style="margin-left:8px;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</button>
    </div>
  </div>
  <div class="small" style="margin-top:8px;opacity:0.9;">â€» ãƒšã‚¢æ•°ã¯æ‰‹å‹•å…¥åŠ›ã§ãã¾ã™ï¼ˆ3ã€œ10ï¼‰ã€‚è¤‡æ•°äººãƒ—ãƒ¬ã‚¤ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šã§ã€‚</div>
</div>

<div id="gameContainer" style="display:none;padding:18px;">
  <div id="turnBanner">
    <span>ğŸ¯ ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³ï¼š</span>
    <span id="turnBadge" class="turn-badge">â€”</span>
    <div style="flex:1"></div>
    <div class="small">å­¦ç¿’å±¥æ­´</div>
  </div>

  <div id="gameArea">
    <div id="cardArea"></div>
    <div style="width:280px;">
      <div style="font-size:20px;font-weight:700;margin-bottom:10px;">å­¦ç¿’å±¥æ­´</div>
      <div id="learnedList"></div>
      <div class="small float-right" style="margin-top:12px;">
        <button onclick="openResult()">ãƒªã‚¶ãƒ«ãƒˆè¡¨ç¤º</button>
        <button onclick="goHome()" style="margin-left:6px;">ãƒ›ãƒ¼ãƒ ã¸</button>
      </div>
    </div>
  </div>
</div>

<div id="setupModal" class="modal-back">
  <div class="modal">
    <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>
    <div>
      <label>äººæ•°ï¼š</label>
      <input id="setupCount" type="number" min="1" max="6" value="2" />
      <button onclick="renderSetupPlayers(Number(setupCount.value))">æ›´æ–°</button>
    </div>
    <div id="setupPlayersList" style="margin-top:10px;"></div>
    <div style="margin-top:14px;text-align:right;">
      <button onclick="applySetup()">OK</button>
      <button onclick="closeSetup()" style="margin-left:6px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
  </div>
</div>
<div id="graphModal" class="modal-back">
  <div class="modal" role="dialog" aria-modal="true">
    <div style="display:flex;align-items:center;justify-content:space-between;">
      <div style="font-weight:800;" id="graphTitle">ã‚°ãƒ©ãƒ•</div>
      <div>
        <button onclick="zoomGraph(1.2)">ï¼‹</button>
        <button onclick="zoomGraph(1/1.2)">ï¼</button>
        <button onclick="closeGraph()" style="margin-left:8px;">é–‰ã˜ã‚‹</button>
      </div>
    </div>
    <canvas id="graphCanvas" width="1200" height="640" style="width:100%; height:80vh; background:#fff; margin-top:10px;"></canvas>
  </div>
</div>

<div id="matchModal" class="modal-back">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-weight:800;" id="matchTitle">ãƒšã‚¢æˆç«‹</div>
      <div><button onclick="closeMatchModal()">é–‰ã˜ã‚‹</button></div>
    </div>
    <div class="tab-buttons" style="margin-top:10px;">
      <button onclick="showMatchTab('formula')">å¼</button>
      <button onclick="showMatchTab('table')">å¯¾å¿œè¡¨</button>
      <button onclick="showMatchTab('graph')">ã‚°ãƒ©ãƒ•</button>
    </div>
    <div id="matchContent" class="tab-content"></div>
  </div>
</div>

<div id="resultModal" class="modal-back">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-weight:800;">ãƒªã‚¶ãƒ«ãƒˆ</div>
      <div><button onclick="closeResult()" style="margin-left:8px;">é–‰ã˜ã‚‹</button></div>
    </div>
    <div style="margin-top:10px;">
      <div id="resultScores" style="margin-bottom:10px;"></div>
      <div style="font-weight:700;">ãƒ—ãƒ¬ã‚¤ã§ä½¿ã‚ã‚ŒãŸä¸€æ¬¡é–¢æ•°ä¸€è¦§</div>
      <div id="usedFunctionsList" style="margin-top:8px;max-height:360px;overflow:auto;"></div>
    </div>
  </div>
</div>

<div id="infoCard" style="display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:90;"></div>

<script>
/* ---------------------------
   ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãƒ»åˆæœŸå€¤
----------------------------*/
let mode = null;
let players = 2;
let playerConfig = [];
let deckCards = []; // for memory or base pool
let firstFlip = null;
let scores = [];
let turnIndex = 0;
let remainingPairs = 0;
let cpuMemory = {};
let selectedPairs = 4;
let selectedCPUStrength = 'normal';
let chosenMode = 'memory';
let disableClicks = false;
let turnTimer = null;
let babaHands = [];
let ownSelected = [];
let usedFunctionsSet = new Set();
let graphScale = 1;

/* ---------------------------
   element refs
----------------------------*/
const homeScreen = document.getElementById('homeScreen');
const gameContainer = document.getElementById('gameContainer');
const cardArea = document.getElementById('cardArea');
const learnedDiv = document.getElementById('learnedList');
const turnBadge = document.getElementById('turnBadge');

const setupModal = document.getElementById('setupModal');
const setupPlayersList = document.getElementById('setupPlayersList');

const graphModal = document.getElementById('graphModal');
const graphCanvas = document.getElementById('graphCanvas');
const graphCtx = graphCanvas ? graphCanvas.getContext('2d') : null; // Nullãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 

const matchModal = document.getElementById('matchModal');
const matchContent = document.getElementById('matchContent');

const resultModal = document.getElementById('resultModal');
const resultScores = document.getElementById('resultScores');
const usedFunctionsList = document.getElementById('usedFunctionsList');

/* ---------------------------
   util functions
----------------------------*/
function randInt(n){ return Math.floor(Math.random()*n); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=randInt(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function formatEq(a,b){
  let aText=(a===1)?"x":(a===-1?"-x":`${a}x`);
  if(b===0) return `y=${aText}`;
  return `y=${aText}${b>0?"+":""}${b}`;
}
function formatNumber(v){ return Number.isInteger(v)?String(v):(Math.round(v*10)/10).toFixed(1); }

/* ---------------------------
   makeTableHTML (ä¿®æ­£: æ¨ªå‘ãè¡¨ç¤ºã«å¤‰æ›´)
----------------------------*/
function makeTableHTML(a,b){
  const xValues=[-2, -1, 0, 1, 2];
  const yValues=xValues.map(x=>a*x+b);
  
  const xRow = xValues.map(x=>`<td>${x}</td>`).join('');
  const yRow = yValues.map(y=>`<td>${formatNumber(y)}</td>`).join('');
  
  return `
    <div class="table-card">
      <div class="title">å¯¾å¿œè¡¨</div>
      <table>
        <tr><th>x</th>${xRow}</tr>
        <tr><th>y</th>${yRow}</tr>
      </table>
    </div>
  `;
}

/* ---------------------------
   Home controls
----------------------------*/
function selectMode(m){
  chosenMode=m;
  const mEmb = document.getElementById('modeMemoryBtn');
  const mAbb = document.getElementById('modeBabaBtn');
  if(mEmb) mEmb.style.opacity=(m==='memory'?1:0.6);
  if(mAbb) mAbb.style.opacity=(m==='babanuki'?1:0.6);
}
function setCPU(level){
  selectedCPUStrength=level;
  const cW = document.getElementById('cpuWeak');
  const cN = document.getElementById('cpuNormal');
  const cS = document.getElementById('cpuStrong');
  if(cW) cW.style.opacity=(level==='weak'?1:0.6);
  if(cN) cN.style.opacity=(level==='normal'?1:0.6);
  if(cS) cS.style.opacity=(level==='strong'?1:0.6);
}
function startGameFromHome(){
  const pairInput = document.getElementById('pairInput');
  const val=Number(pairInput?pairInput.value:4);
  if(isNaN(val)||val<3||val>10){ alert('ãƒšã‚¢æ•°ã¯3ã€œ10ã§å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  selectedPairs=val;
  mode=chosenMode;

  if(!playerConfig || playerConfig.length===0){
    playerConfig=[
      {name:'P1', type:'human', strength:'weak'},
      {name:'P2', type:'cpu', strength:selectedCPUStrength}
    ];
  }
  players = playerConfig.length;
  usedFunctionsSet.clear();

  if(homeScreen) homeScreen.style.display='none';
  if(gameContainer) gameContainer.style.display='block';

  if(mode==='memory') startMemory(selectedPairs);
  else startBabanuki(selectedPairs);

  updateTurnDisplay();
}

/* ---------------------------
   Setup modal
----------------------------*/
function openSetup(){ 
  if(setupModal) setupModal.style.display='flex'; 
  const setupCount = document.getElementById('setupCount');
  if(setupCount) setupCount.value = players; 
  renderSetupPlayers(players); 
}
function closeSetup(){ 
  if(setupModal) setupModal.style.display='none'; 
}
function renderSetupPlayers(n){
  if(setupPlayersList) setupPlayersList.innerHTML='';
  for(let i=0;i<n;i++){
    const cfg = playerConfig[i] || {name:`P${i+1}`, type:'human', strength:'weak'};
    const row = document.createElement('div');
    row.style.margin='6px';
    row.innerHTML = `
      P${i+1} åç§°ï¼š <input id="name_p${i}" value="${cfg.name}" style="width:120px;">
      ã‚¿ã‚¤ãƒ—ï¼š <select id="type_p${i}">
        <option value="human">äººé–“</option>
        <option value="cpu">CPU</option>
      </select>
      <select id="strength_p${i}">
        <option value="weak">å¼±</option>
        <option value="normal">æ™®é€š</option>
        <option value="strong">å¼·</option>
      </select>
    `;
    if(setupPlayersList) setupPlayersList.appendChild(row);
    setTimeout(()=>{ 
      const typeEl = document.getElementById(`type_p${i}`);
      const strengthEl = document.getElementById(`strength_p${i}`);
      if(typeEl) typeEl.value=cfg.type; 
      if(strengthEl) strengthEl.value=cfg.strength; 
    },10);
  }
}
function applySetup(){
  const setupCount = document.getElementById('setupCount');
  const n = Number(setupCount?setupCount.value:players);
  players=n;
  playerConfig=[];
  for(let i=0;i<n;i++){
    const name=document.getElementById(`name_p${i}`)?.value||`P${i+1}`;
    const type=document.getElementById(`type_p${i}`)?.value;
    const strength=document.getElementById(`strength_p${i}`)?.value;
    playerConfig.push({name,type,strength});
  }
  closeSetup();
  updateTurnDisplay();
}
/* ---------------------------
   MEMORYï¼ˆç¥çµŒè¡°å¼±ï¼‰
----------------------------*/
function startMemory(pairCount){
  deckCards=[]; firstFlip=null; scores=Array(players).fill(0); turnIndex=0; cpuMemory={}; disableClicks=false;
  const pool=[];
  for(let a=-4;a<=4;a++) for(let b=-3;b<=3;b++) if(a!==0) pool.push({a,b});
  const selected = shuffle(pool).slice(0,pairCount);
  deckCards=[];
  selected.forEach(s=>{
    const types=['formula','detail','graph','table'];
    const t1=types[randInt(types.length)];
    let t2=types[randInt(types.length)]; // â† ä¿®æ­£: let ã«å¤‰æ›´ï¼ˆå†ä»£å…¥ã™ã‚‹ãŸã‚ï¼‰
    while(t2===t1) t2=types[randInt(types.length)];
    deckCards.push({a:s.a,b:s.b,type:t1});
    deckCards.push({a:s.a,b:s.b,type:t2});
    usedFunctionsSet.add(`${s.a},${s.b}`);
  });
  shuffle(deckCards);
  remainingPairs = deckCards.length/2;
  renderMemoryTable();
  startTurnTimer();
  if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
}

function renderMemoryTable(){
  if(cardArea) cardArea.innerHTML='';
  const grid = document.createElement('div'); grid.className='card-grid';
  deckCards.forEach((c,idx)=>{
    const wrap=document.createElement('div'); wrap.className='card'; wrap.dataset.index=idx;
    const inner=document.createElement('div'); inner.className='card-inner';
    const front=document.createElement('div'); front.className='face front'; front.textContent='?';
    const back=document.createElement('div'); back.className='face back';
    if(c.type==='formula') back.innerHTML=`<div style="font-weight:800">${formatEq(c.a,c.b)}</div>`;
    else if(c.type==='detail') back.innerHTML=`a=${c.a}<br>b=${c.b}`;
    else if(c.type==='graph') { back.innerHTML=`<div style="font-weight:700">ğŸ“ˆ ã‚°ãƒ©ãƒ•</div>`; }
    else if(c.type==='table') back.innerHTML = makeTableHTML(c.a,c.b);
    inner.appendChild(front); inner.appendChild(back); wrap.appendChild(inner); grid.appendChild(wrap);
    
    // ğŸ’¡ ä¿®æ­£: ã‚°ãƒ©ãƒ•ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã®å‡¦ç†ã‚’ä¿®æ­£ã—ã€è£è¿”ã£ãŸã¾ã¾ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
    wrap.addEventListener('click', ()=> {
      if(disableClicks) return;
      if(wrap.classList.contains('matched') || wrap.classList.contains('flipped')) return;

      if(c.type==='graph'){ 
        // ã‚°ãƒ©ãƒ•ã‚’è¡¨ç¤º
        wrap.classList.add('flipped');
        showGraphLarge(c);
        
        // 1.2ç§’å¾Œã«è‡ªå‹•çš„ã«è£è¿”ã™
        setTimeout(() => {
            wrap.classList.remove('flipped');
            // æ—¢ã«1æšç›®ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’è£ã«æˆ»ã—ã€ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†
            if(firstFlip !== null){
                const firstCardEl = document.querySelector(`.card[data-index='${firstFlip}']`);
                if(firstCardEl) firstCardEl.classList.remove('flipped');
                firstFlip = null;
                
                turnIndex = (turnIndex+1)%players;
                updateTurnDisplay();
                startTurnTimer();
                if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
            }
            disableClicks = false;
        }, 1200);
        disableClicks = true; // å‡¦ç†ä¸­ã¯ã‚¯ãƒªãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–

      } else {
        // é€šå¸¸ã®ã‚«ãƒ¼ãƒ‰é¸æŠãƒ­ã‚¸ãƒƒã‚¯
        onCardClickedMemory(idx);
      }
    });
  });
  if(cardArea) cardArea.appendChild(grid);
}

function onCardClickedMemory(idx){
  if(disableClicks) return;
  const card = document.querySelector(`.card[data-index='${idx}']`);
  if(!card) return;
  if(card.classList.contains('matched')||card.classList.contains('flipped')) return;
  revealCardMemory(idx);
}

function revealCardMemory(idx){
  if(disableClicks) return;
  const card = document.querySelector(`.card[data-index='${idx}']`);
  if(!card) return;
  if(card.classList.contains('matched')||card.classList.contains('flipped')) return;
  
  card.classList.add('flipped');
  const c = deckCards[idx];
  const key = `${c.a},${c.b}`;
  if(!cpuMemory[key]) cpuMemory[key] = new Set();
  cpuMemory[key].add(idx);

  if(firstFlip===null){ firstFlip=idx; return; }
  disableClicks=true;
  const first = deckCards[firstFlip], second = deckCards[idx];
  if(first.a===second.a && first.b===second.b){
    setTimeout(()=>{
      const c1=document.querySelector(`.card[data-index='${firstFlip}']`);
      const c2=document.querySelector(`.card[data-index='${idx}']`);
      if(c1) c1.classList.add('matched');
      if(c2) c2.classList.add('matched');
      cpuMemory[key]?.delete(firstFlip);
      cpuMemory[key]?.delete(idx);
      scores[turnIndex] = (scores[turnIndex]||0) + 1;
      remainingPairs--;
      addLearned(first);
      // show match modal with big view (formula/table/graph)
      showMatchModal(first);
      firstFlip=null;
      disableClicks=false;
      if(remainingPairs<=0){
        endMemoryGame();
        return;
      }
      updateTurnDisplay();
      startTurnTimer();
      if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,350);
    },400);
  } else {
    setTimeout(()=>{
      const c1=document.querySelector(`.card[data-index='${firstFlip}']`);
      const c2=document.querySelector(`.card[data-index='${idx}']`);
      if(c1) c1.classList.remove('flipped');
      if(c2) c2.classList.remove('flipped');
      firstFlip=null;
      disableClicks=false;
      turnIndex = (turnIndex+1)%players;
      updateTurnDisplay();
      startTurnTimer();
      if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
    },900);
  }
}

function addLearned(card){
  const text = formatEq(card.a, card.b);
  const div = document.createElement('div');
  div.textContent=text;
  if(learnedDiv) learnedDiv.appendChild(div);
}

/* CPU memory / play */
function cpuPlayMemory(){
  const cpu = playerConfig[turnIndex] || {type:'cpu', strength:'normal'};
  const baseWait = (cpu.strength==='strong')?350:(cpu.strength==='weak'?700:500);
  setTimeout(()=>{
    if(disableClicks) return;

    let pick1=null, pick2=null;
    // try find known pair in memory
    for(const k of Object.keys(cpuMemory)){
      const arr = Array.from(cpuMemory[k]).filter(ix=>{
        const el=document.querySelector(`.card[data-index='${ix}']`);
        return el && !el.classList.contains('matched');
      });
      if(arr.length>=2){
        pick1=arr[0];
        pick2=arr[1];
        break;
      }
    }

    if(pick1===null){
      // pick 1st card randomly
      const available = Array.from(document.querySelectorAll('.card')).map((d,i)=>(!d.classList.contains('matched')&&!d.classList.contains('flipped'))?i:null).filter(x=>x!==null);
      if(available.length===0) return;
      pick1=available[randInt(available.length)];

      // Strong CPU: use memory to find 2nd card
      if(cpu.strength==='strong'){
        const firstCard = deckCards[pick1];
        const key = `${firstCard.a},${firstCard.b}`;
        const knownMatch = Array.from(cpuMemory[key]||[]).find(ix=>ix!==pick1 && !document.querySelector(`.card[data-index='${ix}']`)?.classList.contains('matched'));
        if(knownMatch !== undefined) pick2 = knownMatch;
      }
      
      // If 2nd card still null, pick randomly
      if(pick2===null){
        setTimeout(()=>{
          if(disableClicks) return;
          revealCardMemory(pick1);
          
          setTimeout(()=>{
            const available2 = Array.from(document.querySelectorAll('.card')).map((d,i)=>(!d.classList.contains('matched')&&!d.classList.contains('flipped') && i!==pick1)?i:null).filter(x=>x!==null);
            if(available2.length===0){
              turnIndex = (turnIndex+1)%players;
              updateTurnDisplay();
              startTurnTimer();
              if(playerConfig[turnIndex]&&playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
              return;
            }
            revealCardMemory(available2[randInt(available2.length)]);
          },baseWait);
        },baseWait);
      } else {
        // Strong CPU found a match immediately
        setTimeout(()=>{
          revealCardMemory(pick1);
          setTimeout(()=>revealCardMemory(pick2), baseWait);
        },baseWait);
      }
    } else {
      // CPU found a known pair
      setTimeout(()=>{
        revealCardMemory(pick1);
        setTimeout(()=>revealCardMemory(pick2), baseWait);
      },baseWait);
    }
  },baseWait);
}

/* ---------------------------
   BABA (ãƒãƒæŠœã) æ”¹è‰¯ç‰ˆï¼ˆå††å½¢UIï¼‰
----------------------------*/
function startBabanuki(pairCount){
  deckCards=[]; scores=Array(players).fill(0); turnIndex=0; ownSelected=[]; disableClicks=false;
  const pool=[];
  for(let a=-4;a<=4;a++) for(let b=-3;b<=3;b++) if(a!==0) pool.push({a,b});
  const sel = shuffle(pool).slice(0,pairCount);
  let deck = [];
  sel.forEach(s=>{
    const types=['formula','detail','graph','table'];
    const t1=types[randInt(types.length)];
    let t2=types[randInt(types.length)]; // â† ä¿®æ­£: let ã«å¤‰æ›´ï¼ˆå†ä»£å…¥ã™ã‚‹ãŸã‚ï¼‰
    while(t2===t1) t2=types[randInt(types.length)];
    deck.push({a:s.a,b:s.b,type:t1});
    deck.push({a:s.a,b:s.b,type:t2});
    usedFunctionsSet.add(`${s.a},${s.b}`);
  });
  deck.push({a:null,b:null,text:'JOKER',type:'joker'});
  shuffle(deck);

  babaHands = Array.from({length:players},()=>[]);
  let i=0;
  while(deck.length) { babaHands[i%players].push(deck.pop()); i++; }

  // æœ€åˆã«æ‰‹æœ­ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãƒšã‚¢ã‚’æ¨ã¦ã‚‹
  babaHands.forEach(hand => {
    let discarded = true;
    while(discarded){
      discarded = false;
      const pair = findFirstPairInHand(hand);
      if(pair){
        const ids=[pair.i,pair.j].sort((a,b)=>b-a);
        ids.forEach(ix=>hand.splice(ix,1));
        discarded = true;
      }
    }
  });

  renderBabaUI();
  startTurnTimer();
  // ğŸ’¡ ä¿®æ­£: ã‚²ãƒ¼ãƒ é–‹å§‹å¾Œã«ã‚¿ãƒ¼ãƒ³ã‚’é€²è¡Œã•ã›ã‚‹ã€‚CPUã®æœ€åˆã®ã‚¿ãƒ¼ãƒ³ã¯ nextTurn() ãŒå‡¦ç†ã—ã¾ã™ã€‚
  nextTurn();
}

function renderBabaUI(){
  if(cardArea) cardArea.innerHTML='';
  const container = document.createElement('div');
  container.className='baba-container';
  const circle = document.createElement('div');
  circle.className='circle-wrap';

  const cx = 280, cy = 210, radiusX = 220, radiusY = 140;

  for(let i=0;i<players;i++){
    const angle = (Math.PI*2)/players * i - Math.PI/2;
    const x = cx + radiusX * Math.cos(angle);
    const y = cy + radiusY * Math.sin(angle);
    
    const slot = document.createElement('div');
    slot.className=`player-slot ${i===turnIndex?'current':''}`;
    slot.style.left=`${x-60}px`;
    slot.style.top=`${y-25}px`;

    const panel = document.createElement('div');
    panel.className='slot-panel';
    panel.innerHTML=`
      <div style="font-weight:700;">${playerConfig[i].name}</div>
      <div class="small">æ‰‹æœ­: ${babaHands[i]?.length || 0}æš</div>
    `;
    slot.appendChild(panel);
    
    // ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³ã§ã€ã‹ã¤äººé–“ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å ´åˆã€æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã¨æ‰‹æœ­ã‚’è¡¨ç¤º
    if(i === turnIndex && playerConfig[i].type==='human'){
      const handRow = document.createElement('div');
      handRow.className='hand-row';
      babaHands[i].forEach((c,hi)=>{
        const card = document.createElement('div');
        card.className=`hand-card ${c.type==='joker'?'joker':''} selectable ${ownSelected.some(s=>s.hi===hi)?'selected':''}`;
        card.textContent = c.text || formatEq(c.a,c.b);
        card.onclick=()=>onOwnCardClick(i,hi);
        handRow.appendChild(card);
      });
      panel.appendChild(handRow);
      
      const discardArea = document.createElement('div');
      discardArea.style.marginTop='10px';
      const discardBtn = document.createElement('button');
      discardBtn.textContent='é¸æŠã—ãŸ2æšã‚’æ¨ã¦ã‚‹';
      discardBtn.onclick=()=>confirmDiscard();
      discardArea.appendChild(discardBtn);
      panel.appendChild(discardArea);
      
    } else if(i !== turnIndex && playerConfig[turnIndex] && playerConfig[turnIndex].type==='human'){
      // äººé–“ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã§ã€ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­ã«ãƒ‰ãƒ­ãƒ¼ãƒœã‚¿ãƒ³
      const drawBtn = document.createElement('button');
      drawBtn.className='draw-btn';
      drawBtn.textContent='ã“ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰å¼•ã';
      drawBtn.onclick=()=>humanDrawFrom(i);
      panel.appendChild(drawBtn);
    }
    
    circle.appendChild(slot);
  }

  container.appendChild(circle);
  if(cardArea) cardArea.appendChild(container);

  updateTurnDisplay();
}

/* when human clicks their own card */
function onOwnCardClick(pi,hi){
  if(pi !== turnIndex) return;
  if(!(playerConfig[pi] && playerConfig[pi].type==='human')) return;
  const hand = babaHands[pi];
  if(!hand || !hand[hi]) return;

  // toggle selection for this index among current hand cards
  const foundIndex = ownSelected.findIndex(s=>s.hi===hi); // only check hi since pi is current turnIndex

  if(foundIndex !== -1){
    ownSelected.splice(foundIndex, 1);
  } else {
    ownSelected.push({pi,hi});
    if(ownSelected.length>2) ownSelected.shift();
  }

  // visual highlight: re-render hand cards to reflect selection
  renderBabaUI();
}

/* confirm discard (human) */
function confirmDiscard(){
  if(ownSelected.length<2){
    alert('æ¨ã¦ã‚‹2æšã‚’é¸æŠã—ã¦ãã ã•ã„');
    return;
  }
  const aIdx = ownSelected[0].hi, bIdx = ownSelected[1].hi;
  const hand = babaHands[turnIndex];
  const c1 = hand[aIdx], c2 = hand[bIdx];

  if(!c1 || !c2){
    alert('é¸æŠãŒç„¡åŠ¹ã§ã™');
    ownSelected=[];
    renderBabaUI();
    return;
  }

  if(c1.a===c2.a && c1.b===c2.b && c1.a!==null){
    // remove both (splice careful with indexes)
    const ids = [aIdx,bIdx].sort((x,y)=>y-x);
    ids.forEach(ix=>hand.splice(ix,1));
    ownSelected=[];
    renderBabaUI();
    // show info
    showMatchModal(c1);
    // after removal, next turn
    setTimeout(()=> nextTurn(), 500);
  } else {
    alert('é¸æŠã•ã‚ŒãŸ2æšã¯ãƒšã‚¢ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
    ownSelected=[];
    renderBabaUI();
  }
}

/* human draw from target */
function humanDrawFrom(ti){
  if(ti===turnIndex||disableClicks) return;
  if(!babaHands[ti]||babaHands[ti].length===0) return;

  disableClicks = true; // ã‚¯ãƒªãƒƒã‚¯ç„¡åŠ¹åŒ–

  const pickIdx = randInt(babaHands[ti].length);
  const drawn = babaHands[ti].splice(pickIdx, 1)[0];
  babaHands[turnIndex].push(drawn);
  
  // å¼•ã„ãŸã‚«ãƒ¼ãƒ‰ãŒã‚ã‹ã‚‹ã‚ˆã†ã« briefly show
  const infoCard = document.getElementById('infoCard');
  if(infoCard){
    infoCard.innerHTML=`
      <div class="card-inner" style="transform: rotateY(180deg);">
        <div class="face back" style="background:#0c2a3d; padding:16px;">
          <div style="font-weight:700;">${playerConfig[ti].name} ã‹ã‚‰å¼•ã„ãŸã‚«ãƒ¼ãƒ‰</div>
          <div style="margin-top:8px; font-size:18px;">${drawn.text || formatEq(drawn.a,drawn.b)}</div>
        </div>
      </div>
    `;
    infoCard.style.display='block';
  }

  // å¼•ã„ãŸã‚«ãƒ¼ãƒ‰ã§ãƒšã‚¢ãƒã‚§ãƒƒã‚¯
  setTimeout(()=>{
    if(infoCard) infoCard.style.display='none';
    const pair = findFirstPairInHand(babaHands[turnIndex]);
    if(pair){
      const ids=[pair.i,pair.j].sort((a,b)=>b-a);
      const c1 = babaHands[turnIndex][ids[0]];
      ids.forEach(ix=>babaHands[turnIndex].splice(ix,1));
      showMatchModal(c1);
    }
    disableClicks = false;
    nextTurn();
  }, 1000);
}

/* CPU turn (draw and discard) */
function cpuPlayBaba(){
  const cpu = playerConfig[turnIndex];
  const waitTime = (cpu.strength==='strong')?700:(cpu.strength==='weak'?1500:1000);

  setTimeout(()=>{
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ±ºå®šï¼ˆã‚«ãƒ¼ãƒ‰ãŒæ®‹ã£ã¦ã„ã‚‹æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
    const targetIdx = (turnIndex + 1) % players;
    let currentTarget = targetIdx;
    while(babaHands[currentTarget].length === 0 && currentTarget !== turnIndex){
      currentTarget = (currentTarget + 1) % players;
    }
    // ã‚«ãƒ¼ãƒ‰ãŒæ®‹ã£ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«å¼•ã
    const targetHand = babaHands[currentTarget];
    const pickIdx = randInt(targetHand.length);
    const drawn = targetHand.splice(pickIdx, 1)[0];
    babaHands[turnIndex].push(drawn);

    renderBabaUI();

    // å¼•ã„ãŸã‚«ãƒ¼ãƒ‰ã§ãƒšã‚¢ãƒã‚§ãƒƒã‚¯
    setTimeout(()=>{
      const pair = findFirstPairInHand(babaHands[turnIndex]);
      if(pair){
        const ids=[pair.i,pair.j].sort((a,b)=>b-a);
        const c1 = babaHands[turnIndex][ids[0]];
        ids.forEach(ix=>babaHands[turnIndex].splice(ix,1));
        showMatchModal(c1); // CPUã¯ãƒãƒƒãƒã®ç¢ºèªå¾Œã™ãã«æ¬¡ã¸
      }
      nextTurn();
    }, waitTime);
  }, waitTime);
}

/* Babanukiç”¨ã®ãƒšã‚¢æ¤œç´¢é–¢æ•°ï¼ˆæ‰‹æœ­ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´æ¥å—ã‘å–ã‚‹ï¼‰ */
function findFirstPairInHand(h){
  for(let i=0;i<h.length;i++){
    for(let j=i+1;j<h.length;j++){
      if(h[i].a!==null && h[i].a===h[j].a && h[i].b===h[j].b) return {i,j,a:h[i].a,b:h[i].b};
    }
  }
  return null;
}

/* Babanuki end game */
function endBabaGame(loser){
  stopTurnTimer();
  // JOKERã‚’æŒã¤ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•—è€…
  const winners = playerConfig.filter((p,i)=>p.name !== loser.name).map(p=>p.name);
  // Show result modal
  openResult(winners, 0, loser.name);
}

/* next turn - ğŸ’¡ ä¿®æ­£: TypeErrorå¯¾ç­–ã¨çµ‚äº†åˆ¤å®šã®ãƒ­ã‚¸ãƒƒã‚¯æ”¹å–„ */
function nextTurn(){
  stopTurnTimer();

  // 1. Check for player who has finished (card count 0) and remove them from play
  // babaHands[i]?.length || 0 ã§Null/undefinedãƒã‚§ãƒƒã‚¯ã«å¯¾å¿œ
  const remainingPlayers = playerConfig.map((p,i)=>({hand:babaHands[i], length:babaHands[i]?.length || 0, index:i, name:p.name})).filter(p=>p.length > 0);

  if(remainingPlayers.length <= 1){
    // JOKERã‚’æŒã£ã¦ã„ã‚‹ã®ãŒæœ€å¾Œã®1äººã§ã‚ã‚Œã°ã‚²ãƒ¼ãƒ çµ‚äº†
    if(remainingPlayers.length === 1 && remainingPlayers[0].hand.some(c=>c.type==='joker')){
      endBabaGame(remainingPlayers[0]);
      return;
    }
    // 0äººã®å ´åˆï¼ˆå…¨ã¦ä¸ŠãŒã£ãŸå ´åˆï¼‰
    if(remainingPlayers.length === 0){
      goHome();
      return;
    }
  }

  // 2. Advance turn to the next player who is still in the game
  let nextIndex = (turnIndex + 1) % players;
  let count = 0;
  // æ‰‹æœ­ãŒ0æšã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯
  // babaHands[nextIndex]ãŒundefinedã§ãªã„ã‹ã€ã¾ãŸã¯ãã®é•·ã•ãŒ0ã§ãªã„ã‹ã‚’ç¢ºèª
  while((!babaHands[nextIndex] || babaHands[nextIndex].length === 0) && count < players){
    nextIndex = (nextIndex + 1) % players;
    count++;
  }
  
  // ã‚¹ã‚­ãƒƒãƒ—ãŒå…ƒã®å ´æ‰€ã«æˆ»ã£ãŸã‚‰ï¼ˆå…¨ã¦ä¸ŠãŒã£ã¦ã„ã‚‹ï¼‰ã€å‡¦ç†ã‚’çµ‚äº†
  if (count >= players) {
      goHome(); 
      return;
  }

  turnIndex = nextIndex;
  renderBabaUI();
  startTurnTimer();

  // 3. If next player is CPU, let it play
  if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu'){
    cpuPlayBaba();
  }
}

/* ---------------------------
   modal controls
----------------------------*/
function showGraphLarge(card){
  if(!graphModal || !graphCanvas) return;
  
  if(graphModal) graphModal.style.display='flex';
  const title = document.getElementById('graphTitle');
  if(title) title.textContent = `ã‚°ãƒ©ãƒ•: ${formatEq(card.a, card.b)}`;
  
  graphScale = 1; // Reset scale
  drawGraph(card);
}
function drawGraph(card){
  if(!graphCtx) return;
  const w=graphCanvas.width, h=graphCanvas.height;
  const xCenter=w/2, yCenter=h/2;
  const UNIT_PX = 40 * graphScale; // 1å˜ä½ã‚ãŸã‚Šã®ãƒ”ã‚¯ã‚»ãƒ«æ•°
  const GRID_STEP = 1; // 1ã‚°ãƒªãƒƒãƒ‰ã”ã¨ã®å˜ä½æ•°
  const LABEL_STEP = 2; // ãƒ©ãƒ™ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹ã‚°ãƒªãƒƒãƒ‰é–“éš”

  // Clear
  graphCtx.fillStyle='#fff';
  graphCtx.fillRect(0,0,w,h);
  graphCtx.save();
  graphCtx.translate(xCenter, yCenter);

  // Grid lines
  graphCtx.strokeStyle='#eee';
  graphCtx.lineWidth=1;
  const xMax = Math.ceil(w/2 / UNIT_PX);
  const yMax = Math.ceil(h/2 / UNIT_PX);

  // X lines
  for(let i=1; i<=xMax; i++){
    const px = i * UNIT_PX;
    graphCtx.beginPath();
    graphCtx.moveTo(px, -h/2);
    graphCtx.lineTo(px, h/2);
    graphCtx.stroke();
    graphCtx.beginPath();
    graphCtx.moveTo(-px, -h/2);
    graphCtx.lineTo(-px, h/2);
    graphCtx.stroke();
    // Labels
    if(i % LABEL_STEP === 0){
      graphCtx.fillStyle='#000';
      graphCtx.font=`12px Arial`;
      graphCtx.textAlign='center';
      graphCtx.textBaseline='top';
      if(i !== 0) graphCtx.fillText(i, px, 5);
      if(-i !== 0) graphCtx.fillText(-i, -px, 5);
    }
  }

  // Y lines
  graphCtx.textBaseline='middle';
  graphCtx.textAlign='right';
  for(let i=1; i<=yMax; i++){
    const py = i * UNIT_PX;
    graphCtx.beginPath();
    graphCtx.moveTo(-w/2, py);
    graphCtx.lineTo(w/2, py);
    graphCtx.stroke();
    graphCtx.beginPath();
    graphCtx.moveTo(-w/2, -py);
    graphCtx.lineTo(w/2, -py);
    graphCtx.stroke();
    // Labels
    if(i % LABEL_STEP === 0){
      // Yè»¸ã¯Canvasåº§æ¨™ç³»ã¨åè»¢ã—ã¦ã„ã‚‹ãŸã‚ã€y = i ã®ä½ç½®ã« -i ã®ãƒ©ãƒ™ãƒ«ã€y = -i ã®ä½ç½®ã« i ã®ãƒ©ãƒ™ãƒ«
      graphCtx.fillStyle='#000';
      graphCtx.font=`12px Arial`;
      if(i !== 0) graphCtx.fillText(-i, -5, py); 
      if(-i !== 0) graphCtx.fillText(i, -5, -py); 
    }
  }

  // Axes (bold)
  graphCtx.strokeStyle='#888';
  graphCtx.lineWidth=2;
  graphCtx.beginPath();
  graphCtx.moveTo(-w/2,0);
  graphCtx.lineTo(w/2,0);
  graphCtx.stroke(); // X-axis
  graphCtx.beginPath();
  graphCtx.moveTo(0,-h/2);
  graphCtx.lineTo(0,h/2);
  graphCtx.stroke(); // Y-axis

  // Origin (0)
  graphCtx.textAlign='right';
  graphCtx.textBaseline='top';
  graphCtx.fillText('0', -5, 5);

  // Axis labels (X, Y)
  graphCtx.font=`bold 14px Arial`;
  graphCtx.textAlign='left';
  graphCtx.textBaseline='bottom';
  graphCtx.fillText('x', w/2 - 15, -5);
  graphCtx.textAlign='right';
  graphCtx.textBaseline='top';
  graphCtx.fillText('y', 0, -h/2 + 15);

  // Plot function
  graphCtx.strokeStyle='#d9534f';
  graphCtx.lineWidth=3;
  graphCtx.beginPath();
  let first=true;
  
  // Iterate over pixel coordinates to draw a smooth line
  for(let px=-w/2; px<=w/2; px+=1){
    const x = px / UNIT_PX; // x-unit = px / 40
    const yVal = card.a*x + card.b;
    const py = -yVal * UNIT_PX; // py = -y-unit * 40
    
    if(first){
      graphCtx.moveTo(px,py);
      first=false;
    } else {
      graphCtx.lineTo(px,py);
    }
  }
  graphCtx.stroke();
  graphCtx.restore();
}
function closeGraph(){
  if(graphModal) graphModal.style.display='none';
}
function zoomGraph(factor){
  graphScale *= factor;
  // ç¾åœ¨é–‹ã„ã¦ã„ã‚‹ã‚°ãƒ©ãƒ•ã®ã‚«ãƒ¼ãƒ‰æƒ…å ±ãŒå¿…è¦ã ãŒã€ã“ã“ã§ã¯ç°¡ç•¥åŒ–ã®ãŸã‚å†æç”»ã®ã¿
  const title = document.getElementById('graphTitle');
  if(title && title.textContent.startsWith('ã‚°ãƒ©ãƒ•: y=')){
    const eq = title.textContent.replace('ã‚°ãƒ©ãƒ•: y=','');
    // a, bã‚’å†è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ã“ã“ã§ã¯ç°¡ç•¥åŒ–ã®ãŸã‚ã€ã‚°ãƒ©ãƒ•è¡¨ç¤ºã‚’é–‰ã˜ã‚‹
    // drawGraph(card) ã‚’å‘¼ã³å‡ºã™ã«ã¯ã€cardã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¿æŒãŒå¿…è¦
    alert('ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ã¯æœªå®Ÿè£…ã§ã™ã€‚');
  }
}

function showMatchModal(card){
  if(!matchModal || !matchContent) return;
  
  if(matchModal) matchModal.style.display='flex';
  const title = document.getElementById('matchTitle');
  if(title) title.textContent = `ãƒšã‚¢æˆç«‹: ${formatEq(card.a, card.b)}`;
  
  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€Œå¼ã€ã‚¿ãƒ–ã‚’è¡¨ç¤º
  showMatchTab('formula', card);
}
function showMatchTab(type, card = null){
  if(!matchContent) return;
  
  // cardãŒæ¸¡ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ã€ã‚¿ã‚¤ãƒˆãƒ«ã‹ã‚‰å¾©å…ƒã‚’è©¦ã¿ã‚‹
  if(!card){
    const titleEl = document.getElementById('matchTitle');
    const title = titleEl?.textContent || '';
    const match = title.match(/ãƒšã‚¢æˆç«‹: y=(-?\d*)[xX]([+-]?\d*)/);
    if(match){
        let a = match[1] === '-' ? -1 : (match[1] === '' ? 1 : Number(match[1]));
        let b = Number(match[2] || 0);
        card = {a,b};
    } else {
        return; // å¾©å…ƒã§ããªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
    }
  }

  let content='';
  if(type==='formula'){
    content = `<div style="font-size:32px; font-weight:700; text-align:center; padding:30px;">${formatEq(card.a, card.b)}</div>`;
  } else if(type==='table'){
    content = `<div style="padding:10px;">${makeTableHTML(card.a, card.b)}</div>`;
  } else if(type==='graph'){
    // ã‚°ãƒ©ãƒ•ã¯Canvasã«æç”»ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
    content = `<canvas id="matchGraphCanvas" width="400" height="200" style="width:100%; height:200px; background:#fff; border-radius:6px;"></canvas>`;
    setTimeout(() => {
      drawSmallGraph(card);
    }, 10);
  }
  matchContent.innerHTML = content;
}
function drawSmallGraph(card){
  const canvas = document.getElementById('matchGraphCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const w=canvas.width, h=canvas.height;
  const xCenter=w/2, yCenter=h/2;
  const UNIT_PX = 20; // 1å˜ä½ã‚ãŸã‚Šã®ãƒ”ã‚¯ã‚»ãƒ«æ•°

  // Clear
  ctx.fillStyle='#fff';
  ctx.fillRect(0,0,w,h);
  ctx.save();
  ctx.translate(xCenter, yCenter);

  // Axes
  ctx.strokeStyle='#ccc';
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(-xCenter, 0); ctx.lineTo(xCenter, 0); ctx.stroke(); // X-axis
  ctx.moveTo(0, -yCenter); ctx.lineTo(0, yCenter); ctx.stroke(); // Y-axis

  // Plot function
  ctx.strokeStyle='#d9534f';
  ctx.lineWidth=2;
  ctx.beginPath();
  let first=true;
  for(let px=-w/2; px<=w/2; px+=1){
    const x = px / UNIT_PX;
    const yVal = card.a*x + card.b;
    const py = -yVal * UNIT_PX;
    if(first){ ctx.moveTo(px,py); first=false; }
    else ctx.lineTo(px,py);
  }
  ctx.stroke();
  ctx.restore();
}
function closeMatchModal(){
  if(matchModal) matchModal.style.display='none';
}

function openResult(winners=null, maxScore=0, loser=null){
  if(!resultModal) return;
  resultModal.style.display='flex';
  
  if(resultScores) {
    if(mode==='memory'){
      resultScores.innerHTML = `
        <div style="font-size:24px;font-weight:700;margin-bottom:8px;">å‹è€…: ${winners.join(', ')}</div>
        <div class="small">æˆç«‹ãƒšã‚¢æ•° (${maxScore}ç‚¹)</div>
      `;
    } else if(mode==='babanuki'){
      resultScores.innerHTML = `
        <div style="font-size:24px;font-weight:700;margin-bottom:8px;">å‹è€…: ${winners.join(', ')}</div>
        <div class="small">æ•—è€…: ${loser}</div>
      `;
    }
  }

  // used functions
  if(usedFunctionsList) usedFunctionsList.innerHTML = '';
  const arr = Array.from(usedFunctionsSet).map(s=>{
    const [a,b]=s.split(',');
    return {a:Number(a),b:Number(b)};
  });
  arr.forEach(obj=>{
    const el = document.createElement('div'); el.style.padding='6px'; el.style.borderBottom='1px solid rgba(0,0,0,0.06)';
    el.innerHTML = `<div style="font-weight:700">${formatEq(obj.a,obj.b)}</div><div class="small">${makeTableHTML(obj.a,obj.b)}</div>`;
    if(usedFunctionsList) usedFunctionsList.appendChild(el);
  });
}
function closeResult(){ 
  if(resultModal) resultModal.style.display='none'; 
}

/* ---------------------------
   turn helper
----------------------------*/
function updateTurnDisplay(){
  if(turnBadge){
    if(playerConfig[turnIndex]){
      turnBadge.textContent = playerConfig[turnIndex].name;
    } else {
      turnBadge.textContent = 'â€”';
    }
  }
}
function startTurnTimer(){
  stopTurnTimer();
  turnTimer = setTimeout(()=>{
    // 3åˆ†å¾Œã«ã‚¿ãƒ¼ãƒ³ã‚’å¼·åˆ¶çµ‚äº†ã—ã€æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸
    if(mode==='memory'){
      alert(`${playerConfig[turnIndex].name}ã•ã‚“ã®ã‚¿ãƒ¼ãƒ³æ™‚é–“åˆ‡ã‚Œã§ã™ã€‚æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç§»ã‚Šã¾ã™ã€‚`);
      disableClicks=false;
      firstFlip=null;
      // é–‹ã„ã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’è£ã«æˆ»ã™
      document.querySelectorAll('.card.flipped:not(.matched)').forEach(c=>c.classList.remove('flipped'));
      turnIndex = (turnIndex+1)%players;
      updateTurnDisplay();
      startTurnTimer();
      if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
    } else if(mode==='babanuki' && playerConfig[turnIndex].type==='human'){
      alert(`${playerConfig[turnIndex].name}ã•ã‚“ã®ã‚¿ãƒ¼ãƒ³æ™‚é–“åˆ‡ã‚Œã§ã™ã€‚CPUãŒãƒ©ãƒ³ãƒ€ãƒ ã«ã‚«ãƒ¼ãƒ‰ã‚’å¼•ãã¾ã™ã€‚`);
      ownSelected=[];
      // nextTurn() ã‚’å‘¼ã³å‡ºã™ãŒã€CPUãŒãƒ©ãƒ³ãƒ€ãƒ ã«å¼•ããƒ­ã‚¸ãƒƒã‚¯ã¯ humanDrawFrom ã«ã¯ç„¡ã„ãŸã‚ã€ã“ã“ã§ã¯æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã¸ç§»å‹•
      nextTurn(); 
    }
  }, 180000); // 3åˆ† (180000ms)
}
function stopTurnTimer(){
  if(turnTimer) clearTimeout(turnTimer);
  turnTimer = null;
}

/* ---------------------------
   small helpers (goHome etc.)
----------------------------*/
function goHome(){
  stopTurnTimer(); mode=null;
  
  // ğŸ’¡ ä¿®æ­£: ã™ã¹ã¦ã®è¦ç´ ã§Nullãƒã‚§ãƒƒã‚¯ã‚’å¾¹åº•ã™ã‚‹
  if(gameContainer) gameContainer.style.display='none';
  if(homeScreen) homeScreen.style.display='flex';
  if(cardArea) cardArea.innerHTML=''; 
  if(learnedDiv) learnedDiv.innerHTML='';
  
  // ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ ã‚’å†å–å¾—ã—ã€å­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ“ä½œ
  const gm = document.getElementById('graphModal');
  const mm = document.getElementById('matchModal');
  const rm = document.getElementById('resultModal');
  
  if(gm) gm.style.display='none'; 
  if(mm) mm.style.display='none';
  if(rm) rm.style.display='none';

  turnIndex = 0; // Reset turn index
  babaHands = []; // Reset baba hands
  ownSelected = []; // Reset selected cards
}

/* ---------------------------
   initDefault
----------------------------*/
(function initDefault(){
  players=2;
  playerConfig=[
    {name:'P1', type:'human', strength:'weak'},
    {name:'P2', type:'cpu', strength:'normal'}
  ];
  selectedPairs=4; selectedCPUStrength='normal'; chosenMode='memory';
  
  if(homeScreen) homeScreen.style.display='flex'; 
  if(gameContainer) gameContainer.style.display='none';

  const mEmb = document.getElementById('modeMemoryBtn');
  const mAbb = document.getElementById('modeBabaBtn');
  
  if(mEmb) mEmb.style.opacity=1;
  if(mAbb) mAbb.style.opacity=0.6;
  
  setCPU('normal');
  renderSetupPlayers(players);
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ä¸€æ¬¡é–¢æ•°ãƒˆãƒ©ãƒ³ãƒ— v42ï¼ˆå®Œå…¨å‹•ä½œç‰ˆï¼‰</title>
<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#001428">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<style>
  :root{ --bg1:#001428; --bg2:#00263e; --panel:#021a2d; --accent:#ffd966; }
  html,body{height:100%; margin:0; font-family:"Segoe UI",sans-serif; background:linear-gradient(var(--bg1),var(--bg2)); color:#fff;}
  h1{font-size:40px; font-weight:800;text-align:center;margin:28px 0;}
  .container-box{background:var(--panel); padding:20px 26px; border-radius:14px; max-width: 90%; width: auto; box-shadow:0 0 8px #0007; margin:0 auto;}
  button{padding:8px 10px;border-radius:6px;border:none;cursor:pointer;background:#fff;color:#000;}
  input[type=number]{padding:6px;border-radius:6px;border:none;width:80px;}
  #gameArea{display:flex;gap:32px;padding:24px;}
  #cardArea{flex:1; min-height:420px;}
  .card-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:12px;margin-top:18px;}
  .card{perspective:800px; cursor:pointer; position:relative;}
  .card-inner{transition: transform .45s; transform-style: preserve-3d; position:relative; width:100%; min-height:90px; border-radius:10px;}
  .face{backface-visibility:hidden; position:absolute; left:0; top:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; padding:8px; border-radius:10px;}
  .front{background:#072033; font-size:22px;}
  .back{background:#0c2a3d; transform:rotateY(180deg); overflow:auto; color:#fff; font-size:14px;}
  .card.flipped .card-inner{transform:rotateY(180deg);}
  .card.matched{opacity:0.45; pointer-events:none;}
  .table-card table{border-collapse:collapse; width:100%; table-layout: fixed;}
  .table-card td,.table-card th{padding:4px; border:1px solid rgba(255,255,255,0.06); font-size:13px; text-align:center;}
  .baba-container{display:flex;flex-direction:column;align-items:center;gap:14px}
  .circle-wrap{position:relative;width:560px;height:420px;}
  .player-slot{position:absolute; width:140px; text-align:center; transform-origin:center center;}
  .player-slot .slot-panel{background:rgba(2,40,50,0.85); padding:12px;border-radius:10px;}
  .player-slot.current .slot-panel{box-shadow:0 0 18px var(--accent); border:2px solid rgba(255,217,102,0.2);}
  .player-slot .draw-btn{margin-top:8px;padding:6px;border-radius:6px;background:#fff;color:#000;cursor:pointer;}
  .hand-row{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding-top:8px;}
  .hand-card{background:#06313f;padding:8px;border-radius:8px;min-width:80px;min-height:50px;display:flex;align-items:center;justify-content:center;text-align:center;cursor:default;}
  .hand-card.selectable{cursor:pointer; outline:none;}
  .hand-card.selected{outline:3px solid #ffd966;}
  .hand-card.pair-highlight{outline:3px solid #4caf50; transform:scale(1.03); transition:0.18s;}
  .hand-card.drawn-highlight{outline:4px solid #ffeb3b; transform:scale(1.06); transition:0.18s;}
  .modal-back{display:none; position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:100; align-items:center; justify-content:space-around;}
  .modal{background:#fff;color:#000;border-radius:10px;padding:14px; max-height:90vh; overflow:auto;}
  #graphModal .modal{width:80vw; max-width:1100px; height:80vh;}
  #matchModal .modal{width:640px;}
  #resultModal .modal{width:720px;}
  .tab-buttons{display:flex;gap:6px;margin-bottom:8px;}
  .tab-buttons button{background:#eee;color:#000;padding:6px 8px;border-radius:6px;border:none;cursor:pointer;}
  .tab-content{background:#fff;padding:8px;border-radius:6px;min-height:160px;}
  #turnBanner{font-size:22px;font-weight:800;margin-bottom:16px;display:flex;align-items:center;gap:8px;}
  .turn-badge{background:var(--panel); padding:6px 10px;border-radius:10px;}
  #learnedList{padding-left:6px;font-size:15px;max-height:360px;overflow:auto;}
  .small{font-size:13px;opacity:0.9;}
  .float-right{text-align:right;}
  .discard-ui{
    position: fixed;
    left: 50%;
    top: 18%;
    transform: translateX(-50%);
    background: #021a2d;
    color: #fff;
    padding: 12px 14px;
    border-radius: 10px;
    z-index: 999;
    box-shadow: 0 6px 30px rgba(0,0,0,0.6);
    display: none;
    align-items:center;
    gap:10px;
  }
  .discard-ui button{background:#fff;color:#000;border-radius:6px;padding:6px 10px;}
  .discard-info{font-weight:700;margin-right:8px;}
  .install-pwa-btn{
    position: fixed;
    bottom: 10px; right: 10px;
    z-index: 9999;
    background: var(--accent,#ffd966);
    color:#222;font-weight:700;
    border: none; border-radius:8px;
    padding: 12px 16px;font-size:18px;
    box-shadow:0 2px 8px #3335;
    cursor:pointer;display:none;
  }
  @media screen and (max-width: 768px) {
    h1{ font-size: 28px; margin: 18px 0; }
    .container-box{ max-width: 95%; padding: 16px; }
    #gameArea{flex-direction: column; gap: 16px; padding: 8px;}
    #gameArea > div:nth-child(2) { width: 100% !important; }
    .circle-wrap{ width: 100%; height: 360px; }
    .player-slot{ width: 100px; }
    .baba-container{ display: block; }
    .hand-card{ min-width: 60px; min-height: 40px; font-size: 12px; padding: 4px; }
    #graphModal .modal{ width: 95vw; max-width: 95vw; height: 90vh; margin: 10px;}
    #matchModal .modal{ width: 90vw;}
    #resultModal .modal{ width: 90vw;}
  }
</style>
</head>
<body>
<h1>ä¸€æ¬¡é–¢æ•°ãƒˆãƒ©ãƒ³ãƒ— v42ï¼ˆå®Œå…¨å‹•ä½œç‰ˆï¼‰</h1>

<!-- æ¨ã¦é¸æŠUIï¼ˆã‚¿ã‚¤ãƒãƒ¼ï¼‰ -->
<div id="discardChoiceUI" class="discard-ui" role="dialog" aria-modal="true">
  <div class="discard-info">ãƒšã‚¢ã‚’æ¨ã¦ã¾ã™ã‹ï¼Ÿ (<span id="discardTimer">5</span>)</div>
  <div style="display:flex;gap:8px;">
    <button id="discardYesBtn">æ¨ã¦ã‚‹</button>
    <button id="discardSkipBtn">ã‚¹ã‚­ãƒƒãƒ—</button>
  </div>
</div>

<div id="homeScreen" style="display:flex;flex-direction:column;align-items:center;margin-top:10px;">
  <div class="container-box">
    <div style="font-size:20px;font-weight:700;margin-bottom:6px;">ãƒ¢ãƒ¼ãƒ‰ãƒ»ãƒšã‚¢æ•°ãƒ»CPUå¼·ã•ã‚’é¸ã‚“ã§ â–¶ ã‚²ãƒ¼ãƒ é–‹å§‹</div>
    <div style="margin-top:12px;">
      <div style="font-size:18px;font-weight:700;">ãƒ¢ãƒ¼ãƒ‰</div>
      <button id="modeMemoryBtn" onclick="selectMode('memory')" style="margin-right:8px;">ğŸ§  ç¥çµŒè¡°å¼±</button>
      <button id="modeBabaBtn" onclick="selectMode('babanuki')">ğŸƒ ãƒãƒæŠœã</button>
    </div>
    <div style="margin-top:16px;">
      <div style="font-size:18px;font-weight:700;">ãƒšã‚¢æ•°ï¼ˆ3ã€œ10ï¼‰</div>
      <input id="pairInput" type="number" min="3" max="10" value="4" />
    </div>
    <div style="margin-top:16px;">
      <div style="font-size:18px;font-weight:700;">CPU ã®å¼·ã•</div>
      <button id="cpuWeak" onclick="setCPU('weak')">å¼±</button>
      <button id="cpuNormal" onclick="setCPU('normal')" style="margin-left:6px;">æ™®é€š</button>
      <button id="cpuStrong" onclick="setCPU('strong')" style="margin-left:6px;">å¼·</button>
    </div>
    <div style="margin-top:22px;">
      <button onclick="startGameFromHome()">â–¶ ã‚²ãƒ¼ãƒ é–‹å§‹</button>
      <button onclick="openSetup()" style="margin-left:8px;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</button>
    </div>
  </div>
  <div class="small" style="margin-top:8px;opacity:0.9;">â€» ãƒšã‚¢æ•°ã¯æ‰‹å‹•å…¥åŠ›ã§ãã¾ã™ï¼ˆ3ã€œ10ï¼‰ã€‚è¤‡æ•°äººãƒ—ãƒ¬ã‚¤ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šã§ã€‚</div>
</div>
<div id="gameContainer" style="display:none;padding:18px;">
  <div id="turnBanner">
    <span>ğŸ¯ ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³ï¼š</span>
    <span id="turnBadge" class="turn-badge">â€”</span>
    <div style="flex:1"></div>
    <div class="small">å­¦ç¿’å±¥æ­´</div>
  </div>
  <div id="gameArea">
    <div id="cardArea"></div>
    <div style="width:280px;">
      <div style="font-size:20px;font-weight:700;margin-bottom:10px;">å­¦ç¿’å±¥æ­´</div>
      <div id="learnedList"></div>
      <div class="small float-right" style="margin-top:12px;">
        <button onclick="openResult()">ãƒªã‚¶ãƒ«ãƒˆè¡¨ç¤º</button>
        <button onclick="goHome()" style="margin-left:6px;">ãƒ›ãƒ¼ãƒ ã¸</button>
      </div>
    </div>
  </div>
</div>

<div id="setupModal" class="modal-back">
  <div class="modal">
    <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>
    <div>
      <label>äººæ•°ï¼š</label>
      <input id="setupCount" type="number" min="1" max="6" value="2" />
      <button onclick="renderSetupPlayers(Number(setupCount.value))">æ›´æ–°</button>
    </div>
    <div id="setupPlayersList" style="margin-top:10px;"></div>
    <div style="margin-top:14px;text-align:right;">
      <button onclick="applySetup()">OK</button>
      <button onclick="closeSetup()" style="margin-left:6px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
  </div>
</div>

<div id="graphModal" class="modal-back">
  <div class="modal" role="dialog" aria-modal="true">
    <div style="display:flex;align-items:center;justify-content:space-between;">
      <div style="font-weight:800;" id="graphTitle">ã‚°ãƒ©ãƒ•</div>
      <div>
        <button onclick="zoomGraph(1.2)">ï¼‹</button>
        <button onclick="zoomGraph(1/1.2)">ï¼</button>
        <button onclick="closeGraph()" style="margin-left:8px;">é–‰ã˜ã‚‹</button>
      </div>
    </div>
    <canvas id="graphCanvas" width="1200" height="640" style="width:100%; height:80vh; background:#fff; margin-top:10px;"></canvas>
  </div>
</div>

<div id="matchModal" class="modal-back">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-weight:800;" id="matchTitle">ãƒšã‚¢æˆç«‹</div>
      <div><button onclick="closeMatchModal()">é–‰ã˜ã‚‹</button></div>
    </div>
    <div class="tab-buttons" style="margin-top:10px;">
      <button onclick="showMatchTab('formula')">å¼</button>
      <button onclick="showMatchTab('table')">å¯¾å¿œè¡¨</button>
      <button onclick="showMatchTab('graph')">ã‚°ãƒ©ãƒ•</button>
    </div>
    <div id="matchContent" class="tab-content"></div>
  </div>
</div>

<div id="resultModal" class="modal-back">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-weight:800;">ãƒªã‚¶ãƒ«ãƒˆ</div>
      <div><button onclick="closeResult()" style="margin-left:8px;">é–‰ã˜ã‚‹</button></div>
    </div>
    <div style="margin-top:10px;">
      <div id="resultScores" style="margin-bottom:10px;"></div>
      <div style="font-weight:700;">ãƒ—ãƒ¬ã‚¤ã§ä½¿ã‚ã‚ŒãŸä¸€æ¬¡é–¢æ•°ä¸€è¦§</div>
      <div id="usedFunctionsList" style="margin-top:8px;max-height:360px;overflow:auto;"></div>
    </div>
  </div>
</div>

<div id="infoCard" style="display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:90;"></div>

<div id="cpuCardModal" class="modal-back" style="display:none;">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-weight:800;">CPU ãŒã‚ãã£ãŸã‚«ãƒ¼ãƒ‰</div>
      <div><button onclick="closeCpuCardModal()">é–‰ã˜ã‚‹</button></div>
    </div>
    <div id="cpuCardContent" style="margin-top:10px;font-size:22px;font-weight:700;"></div>
  </div>
</div>

<button id="installPwaBtn" class="install-pwa-btn">ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ </button>
<script>
/* ===== PWA & SW (å®‰å…¨ã«) ===== */
let deferredPrompt;
const installBtn = document.getElementById('installPwaBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = 'block';
});
if(installBtn) installBtn.addEventListener('click', async () => {
  if(deferredPrompt){
    deferredPrompt.prompt();
    await deferredPrompt.userChoice;
    deferredPrompt = null;
    installBtn.style.display = 'none';
  }
});
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('./service-worker.js').then(()=>console.log('SW registered')).catch(()=>console.log('SW registration failed'));
}

/* ===== ã‚²ãƒ¼ãƒ æœ¬ä½“ ===== */
let mode = null;
let players = 2;
let playerConfig = [];
let deckCards = [];
let firstFlip = null;
let scores = [];
let turnIndex = 0;
let remainingPairs = 0;
let cpuMemory = {};
let selectedPairs = 4;
let selectedCPUStrength = 'normal';
let chosenMode = 'memory';
let disableClicks = false;
let cpuWaitFlag = false;

let turnTimer = null;
let babaHands = [];
let ownSelected = [];
let usedFunctionsSet = new Set();
let graphScale = 1;

/* æ–°ï¼šæ¨ã¦ãƒ¢ãƒ¼ãƒ‰åˆ¶å¾¡ */
let discardMode = false;
let selectablePairs = []; // for human: array of [i,j] index pairs in their hand
let discardInterval = null;

const homeScreen = document.getElementById('homeScreen');
const gameContainer = document.getElementById('gameContainer');
const cardArea = document.getElementById('cardArea');
const learnedDiv = document.getElementById('learnedList');
const turnBadge = document.getElementById('turnBadge');
const setupModal = document.getElementById('setupModal');
const setupPlayersList = document.getElementById('setupPlayersList');
const graphModal = document.getElementById('graphModal');
const graphCanvas = document.getElementById('graphCanvas');
const graphCtx = graphCanvas ? graphCanvas.getContext('2d') : null;
const matchModal = document.getElementById('matchModal');
const matchContent = document.getElementById('matchContent');
const resultModal = document.getElementById('resultModal');
const resultScores = document.getElementById('resultScores');
const usedFunctionsList = document.getElementById('usedFunctionsList');

const discardUI = document.getElementById('discardChoiceUI');
const discardTimerEl = document.getElementById('discardTimer');
const discardYesBtn = document.getElementById('discardYesBtn');
const discardSkipBtn = document.getElementById('discardSkipBtn');

discardYesBtn.addEventListener('click', () => {
  const current = turnIndex;
  hideDiscardChoiceUI();
  enableDiscardModeForPlayer(current);
});
discardSkipBtn.addEventListener('click', () => {
  hideDiscardChoiceUI();
  nextTurn();
});

function waitCpuStop(){
  return new Promise(resolve=>{
    const timer = setInterval(()=>{
      if(!cpuWaitFlag){
        clearInterval(timer);
        resolve();
      }
    },100);
  });
}
function showCpuCard(card){
  cpuWaitFlag = true;
  const modal = document.getElementById('cpuCardModal');
  const cont = document.getElementById('cpuCardContent');
  if(cont) cont.innerHTML = card.text || formatEq(card.a, card.b);
  if(modal) modal.style.display='flex';
}
function closeCpuCardModal(){
  const modal = document.getElementById('cpuCardModal');
  if(modal) modal.style.display='none';
  cpuWaitFlag = false;
}

function getCpuParams(strength){
  if(strength === 'weakest'){ return {delay:1800, memory:0}; }
  if(strength === 'weak'){ return {delay:1100, memory:0.2}; }
  if(strength === 'normal'){ return {delay:700, memory:0.6}; }
  if(strength === 'strong'){ return {delay:450, memory:1.0}; }
  return {delay:900, memory:0.3};
}

function randInt(n){ return Math.floor(Math.random()*n); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=randInt(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function formatEq(a,b){
  let aText=(a===1)?"x":(a===-1?"-x":`${a}x`);
  if(b===0) return `y=${aText}`;
  return `y=${aText}${b>0?"+":""}${b}`;
}
function formatNumber(v){ return Number.isInteger(v)?String(v):(Math.round(v*10)/10).toFixed(1); }
function makeTableHTML(a,b){
  const xValues=[-2, -1, 0, 1, 2];
  const yValues=xValues.map(x=>a*x+b);
  const xRow = xValues.map(x=>`<td>${x}</td>`).join('');
  const yRow = yValues.map(y=>`<td>${formatNumber(y)}</td>`).join('');
  return `
    <div class="table-card">
      <div class="title">å¯¾å¿œè¡¨</div>
      <table>
        <tr><th>x</th>${xRow}</tr>
        <tr><th>y</th>${yRow}</tr>
      </table>
    </div>
  `;
}

/* ===== ãƒ›ãƒ¼ãƒ  / ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ===== */
function selectMode(m){
  chosenMode=m;
  const mEmb = document.getElementById('modeMemoryBtn');
  const mAbb = document.getElementById('modeBabaBtn');
  if(mEmb) mEmb.style.opacity=(m==='memory'?1:0.6);
  if(mAbb) mAbb.style.opacity=(m==='babanuki'?1:0.6);
}
function setCPU(level){
  selectedCPUStrength=level;
  const cW = document.getElementById('cpuWeak');
  const cN = document.getElementById('cpuNormal');
  const cS = document.getElementById('cpuStrong');
  if(cW) cW.style.opacity=(level==='weak'?1:0.6);
  if(cN) cN.style.opacity=(level==='normal'?1:0.6);
  if(cS) cS.style.opacity=(level==='strong'?1:0.6);
}
function startGameFromHome(){
  const pairInput = document.getElementById('pairInput');
  const val=Number(pairInput?pairInput.value:4);
  if(isNaN(val)||val<3||val>10){ alert('ãƒšã‚¢æ•°ã¯3ã€œ10ã§å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  selectedPairs=val;
  mode=chosenMode;

  if(!playerConfig || playerConfig.length===0){
    playerConfig=[
      {name:'P1', type:'human', strength:'weak'},
      {name:'P2', type:'cpu', strength:selectedCPUStrength}
    ];
  }
  players = playerConfig.length;
  usedFunctionsSet.clear();

  if(homeScreen) homeScreen.style.display='none';
  if(gameContainer) gameContainer.style.display='block';

  if(mode==='memory') startMemory(selectedPairs);
  else startBabanuki(selectedPairs);

  updateTurnDisplay();
}

function openSetup(){ 
  if(setupModal) setupModal.style.display='flex'; 
  const setupCount = document.getElementById('setupCount');
  if(setupCount) setupCount.value = players; 
  renderSetupPlayers(players); 
}
function closeSetup(){ 
  if(setupModal) setupModal.style.display='none'; 
}
function renderSetupPlayers(n){
  if(setupPlayersList) setupPlayersList.innerHTML='';
  for(let i=0;i<n;i++){
    const cfg = playerConfig[i] || {name:`P${i+1}`, type:'human', strength:'weak'};
    const row = document.createElement('div');
    row.style.margin='6px';
    row.innerHTML = `
      P${i+1} åç§°ï¼š <input id="name_p${i}" value="${cfg.name}" style="width:120px;">
      ã‚¿ã‚¤ãƒ—ï¼š <select id="type_p${i}">
        <option value="human">äººé–“</option>
        <option value="cpu">CPU</option>
      </select>
      <select id="strength_p${i}">
        <option value="weak">å¼±</option>
        <option value="normal">æ™®é€š</option>
        <option value="strong">å¼·</option>
      </select>
    `;
    if(setupPlayersList) setupPlayersList.appendChild(row);
    setTimeout(()=>{ 
      const typeEl = document.getElementById(`type_p${i}`);
      const strengthEl = document.getElementById(`strength_p${i}`);
      if(typeEl) typeEl.value=cfg.type; 
      if(strengthEl) strengthEl.value=cfg.strength; 
    },10);
  }
}
function applySetup(){
  const setupCount = document.getElementById('setupCount');
  const n = Number(setupCount?setupCount.value:players);
  players=n;
  playerConfig=[];
  for(let i=0;i<n;i++){
    const name=document.getElementById(`name_p${i}`)?.value||`P${i+1}`;
    const type=document.getElementById(`type_p${i}`)?.value;
    const strength=document.getElementById(`strength_p${i}`)?.value;
    playerConfig.push({name,type,strength});
  }
  closeSetup();
  updateTurnDisplay();
}

/* ===== MEMORY mode (unchanged largely) ===== */
function startMemory(pairCount){
  deckCards=[]; firstFlip=null; scores=Array(players).fill(0); turnIndex=0; cpuMemory={}; disableClicks=false;
  const pool=[];
  for(let a=-4;a<=4;a++) for(let b=-3;b<=3;b++) if(a!==0) pool.push({a,b});
  const selected = shuffle(pool).slice(0,pairCount);
  deckCards=[];
  selected.forEach(s=>{
    const types=['formula','detail','graph','table'];
    const t1=types[randInt(types.length)];
    let t2=types[randInt(types.length)];
    while(t2===t1) t2=types[randInt(types.length)];
    deckCards.push({a:s.a,b:s.b,type:t1});
    deckCards.push({a:s.a,b:s.b,type:t2});
    usedFunctionsSet.add(`${s.a},${s.b}`);
  });
  shuffle(deckCards);
  remainingPairs = deckCards.length/2;
  renderMemoryTable();
  startTurnTimer();
  if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
}
function renderMemoryTable(){
  if(cardArea) cardArea.innerHTML='';
  const grid = document.createElement('div'); grid.className='card-grid';
  deckCards.forEach((c,idx)=>{
    const wrap=document.createElement('div'); wrap.className='card'; wrap.dataset.index=idx;
    const inner=document.createElement('div'); inner.className='card-inner';
    const front=document.createElement('div'); front.className='face front'; front.textContent='?';
    const back=document.createElement('div'); back.className='face back';
    if(c.type==='formula') back.innerHTML=`<div style="font-weight:800">${formatEq(c.a,c.b)}</div>`;
    else if(c.type==='detail') back.innerHTML=`a=${c.a}<br>b=${c.b}`;
    else if(c.type==='graph') { back.innerHTML=`<div style="font-weight:700">ğŸ“ˆ ã‚°ãƒ©ãƒ•</div>`; }
    else if(c.type==='table') back.innerHTML = makeTableHTML(c.a,c.b);
    inner.appendChild(front); inner.appendChild(back); wrap.appendChild(inner); grid.appendChild(wrap);

    wrap.addEventListener('click', ()=> {
      if(disableClicks) return;
      if(wrap.classList.contains('matched') || wrap.classList.contains('flipped')) return;

      if(c.type==='graph'){ 
        wrap.classList.add('flipped');
        showGraphLarge(c);
        setTimeout(() => {
            wrap.classList.remove('flipped');
            if(firstFlip !== null){
                const firstCardEl = document.querySelector(`.card[data-index='${firstFlip}']`);
                if(firstCardEl) firstCardEl.classList.remove('flipped');
                firstFlip = null;
                turnIndex = (turnIndex+1)%players;
                updateTurnDisplay();
                startTurnTimer();
                if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
            }
            disableClicks = false;
        }, 1200);
        disableClicks = true;
      } else {
        onCardClickedMemory(idx);
      }
    });
  });
  if(cardArea) cardArea.appendChild(grid);
}
function onCardClickedMemory(idx){
  if(disableClicks) return;
  const card = document.querySelector(`.card[data-index='${idx}']`);
  if(!card) return;
  if(card.classList.contains('matched')||card.classList.contains('flipped')) return;
  revealCardMemory(idx);
}
function revealCardMemory(idx, fromCpu=false){
  if(disableClicks) return;
  const card = document.querySelector(`.card[data-index='${idx}']`);
  if(!card) return;
  if(card.classList.contains('matched')||card.classList.contains('flipped')) return;

  card.classList.add('flipped');
  const c = deckCards[idx];
  const key = `${c.a},${c.b}`;
  if(!cpuMemory[key]) cpuMemory[key] = new Set();
  cpuMemory[key].add(idx);

  if(firstFlip===null){ firstFlip=idx; return; }
  disableClicks=true;
  const first = deckCards[firstFlip], second = deckCards[idx];

  if(first.a===second.a && first.b===second.b){
    setTimeout(()=>{
      const c1=document.querySelector(`.card[data-index='${firstFlip}']`);
      const c2=document.querySelector(`.card[data-index='${idx}']`);
      if(c1) c1.classList.add('matched');
      if(c2) c2.classList.add('matched');
      cpuMemory[key]?.delete(firstFlip);
      cpuMemory[key]?.delete(idx);
      scores[turnIndex] = (scores[turnIndex]||0) + 1;
      remainingPairs--;
      addLearned(first);
      showMatchModal(first);
      firstFlip=null;
      disableClicks=false;
      if(remainingPairs<=0){
        endMemoryGame();
        return;
      }
      updateTurnDisplay();
      startTurnTimer();
      if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,350);
    },400);
  } else {
    setTimeout(()=>{
      const c1=document.querySelector(`.card[data-index='${firstFlip}']`);
      const c2=document.querySelector(`.card[data-index='${idx}']`);
      if(c1) c1.classList.remove('flipped');
      if(c2) c2.classList.remove('flipped');
      firstFlip=null;
      disableClicks=false;
      turnIndex = (turnIndex+1)%players;
      updateTurnDisplay();
      startTurnTimer();
      if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
    },1200);
  }
}
function addLearned(card){
  const text = formatEq(card.a, card.b);
  const div = document.createElement('div');
  div.textContent=text;
  if(learnedDiv) learnedDiv.appendChild(div);
}
async function cpuFlipMemory(idx){
  revealCardMemory(idx,true);
  const c = deckCards[idx];
  showCpuCard(c);
  await waitCpuStop();
}
async function cpuPlayMemory(){
  const cpu = playerConfig[turnIndex];
  if(!cpu) return;
  const param = getCpuParams(cpu.strength || selectedCPUStrength);

  await new Promise(r=>setTimeout(r,param.delay));
  if(disableClicks) return;

  let pick1 = null, pick2 = null;
  if(Math.random() < param.memory){
    for(const k of Object.keys(cpuMemory)){
      const arr = Array.from(cpuMemory[k]).filter(ix=>{
        const el = document.querySelector(`.card[data-index='${ix}']`);
        return el && !el.classList.contains('matched') && !el.classList.contains('flipped');
      });
      if(arr.length >= 2){
        pick1 = arr[0];
        pick2 = arr[1];
        break;
      }
    }
  }
  const available = Array.from(document.querySelectorAll('.card')).map((d,i)=>(!d.classList.contains('matched')&&!d.classList.contains('flipped'))?i:null).filter(x=>x!==null);
  if(available.length === 0) return;
  if(pick1 === null) pick1 = available[randInt(available.length)];

  if(pick2 === null && cpu.strength === 'strong'){
    const firstCard = deckCards[pick1];
    const key = `${firstCard.a},${firstCard.b}`;
    const known = Array.from(cpuMemory[key]||[]).find(ix=>ix!==pick1 && !document.querySelector(`.card[data-index='${ix}']`)?.classList.contains('matched') && !document.querySelector(`.card[data-index='${ix}']`)?.classList.contains('flipped'));
    if(known !== undefined) pick2 = known;
  }

  if(pick2 === null){
    const avail2 = Array.from(document.querySelectorAll('.card')).map((d,i)=>(!d.classList.contains('matched')&&!d.classList.contains('flipped') && i!==pick1)?i:null).filter(x=>x!==null);
    if(avail2.length === 0){
      turnIndex = (turnIndex+1)%players;
      updateTurnDisplay();
      startTurnTimer();
      if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') setTimeout(cpuPlayMemory,400);
      return;
    }
    pick2 = avail2[randInt(avail2.length)];
  }

  revealCardMemory(pick1, true);
  showCpuCard(deckCards[pick1]);
  await waitCpuStop();
  await new Promise(r=>setTimeout(r, Math.max(150, param.delay/2)));

  revealCardMemory(pick2, true);
  showCpuCard(deckCards[pick2]);
  await waitCpuStop();
}

/* ===== Babanuki (ãƒãƒæŠœã) ===== */
function startBabanuki(pairCount){
  deckCards=[]; scores=Array(players).fill(0); turnIndex=0; ownSelected=[]; disableClicks=false;
  const pool=[];
  for(let a=-4;a<=4;a++) for(let b=-3;b<=3;b++) if(a!==0) pool.push({a,b});
  const sel = shuffle(pool).slice(0,pairCount);
  let deck = [];
  sel.forEach(s=>{
    const types=['formula','detail','graph','table'];
    const t1=types[randInt(types.length)];
    let t2=types[randInt(types.length)];
    while(t2===t1) t2=types[randInt(types.length)];
    deck.push({a:s.a,b:s.b,type:t1});
    deck.push({a:s.a,b:s.b,type:t2});
    usedFunctionsSet.add(`${s.a},${s.b}`);
  });
  deck.push({a:null,b:null,text:'JOKER',type:'joker'});
  shuffle(deck);

  babaHands = Array.from({length:players},()=>[]);
  let i=0;
  while(deck.length) { babaHands[i%players].push(deck.pop()); i++; }
  babaHands.forEach(hand => {
    let discarded = true;
    while(discarded){
      discarded = false;
      const pair = findFirstPairInHand(hand);
      if(pair){
        const ids=[pair.i,pair.j].sort((a,b)=>b-a);
        ids.forEach(ix=>hand.splice(ix,1));
        discarded = true;
      }
    }
  });
  renderBabaUI();
  startTurnTimer();
  if(playerConfig[turnIndex] && playerConfig[turnIndex].type==='cpu') {
    setTimeout(cpuPlayBaba, 600);
  }
}

function renderBabaUI(){
  if(cardArea) cardArea.innerHTML='';
  const container = document.createElement('div');
  container.className='baba-container';
  const circle = document.createElement('div');
  circle.className='circle-wrap';

  const cx = 280, cy = 210, radiusX = 220, radiusY = 140;

  for(let i=0;i<players;i++){
    const angle = (Math.PI*2)/players * i - Math.PI/2;
    const x = cx + radiusX * Math.cos(angle);
    const y = cy + radiusY * Math.sin(angle);
    const slot = document.createElement('div');
    slot.className=`player-slot ${i===turnIndex?'current':''}`;
    slot.style.left=`${x-70}px`;
    slot.style.top=`${y-25}px`;

    const panel = document.createElement('div');
    panel.className='slot-panel';
    panel.innerHTML=`
      <div style="font-weight:700;">${playerConfig[i].name}</div>
      <div class="small">æ‰‹æœ­: ${babaHands[i]?.length || 0}æš</div>
    `;
    slot.appendChild(panel);
    if(i === turnIndex && playerConfig[i].type==='human'){
      const handRow = document.createElement('div');
      handRow.className='hand-row';
      babaHands[i].forEach((c,hi)=>{
        const card = document.createElement('div');
        card.className=`hand-card ${c.type==='joker'?'joker':''} selectable ${ownSelected.some(s=>s.hi===hi)?'selected':''}`;
        card.id = `hand-${i}-${hi}`;
        card.dataset.pi = i;
        card.dataset.hi = hi;
        card.dataset.a = c.a;
        card.dataset.b = c.b;
        card.textContent = c.text || formatEq(c.a,c.b);
        card.onclick=()=>onBabaHandCardClick(i,hi);
        handRow.appendChild(card);
      });
      panel.appendChild(handRow);
      const discardArea = document.createElement('div');
      discardArea.style.marginTop='10px';
      const discardBtn = document.createElement('button');
      discardBtn.textContent='é¸æŠã—ãŸ2æšã‚’æ¨ã¦ã‚‹';
      discardBtn.onclick=()=>confirmDiscard();
      discardArea.appendChild(discardBtn);
      panel.appendChild(discardArea);
    } else if(i !== turnIndex && playerConfig[turnIndex] && playerConfig[turnIndex].type==='human'){
      const drawBtn = document.createElement('button');
      drawBtn.className='draw-btn';
      drawBtn.textContent='ã“ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰å¼•ã';
      drawBtn.onclick=()=>humanDrawFrom(i);
      panel.appendChild(drawBtn);
    }
    circle.appendChild(slot);
  }

  container.appendChild(circle);
  if(cardArea) cardArea.appendChild(container);
  updateTurnDisplay();
}

/* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­ã‚¯ãƒªãƒƒã‚¯ï¼ˆãƒãƒï¼‰ */
function onBabaHandCardClick(pi,hi){
  // If discard mode active and this player's discard selectablePairs contains hi -> perform discard
  if(discardMode && turnIndex === pi){
    const pair = selectablePairs.find(p => p[0] === hi || p[1] === hi);
    if(pair){
      discardPairFromHand(pi, pair);
      endDiscardMode();
      nextTurn();
      return;
    }
    return;
  }

  // Normal selection for manual discard (two-card selection) if human's turn
  if(pi === turnIndex && playerConfig[pi].type === 'human'){
    const foundIndex = ownSelected.findIndex(s=>s.hi===hi);
    if(foundIndex !== -1){
      ownSelected.splice(foundIndex, 1);
    } else {
      ownSelected.push({pi,hi});
      if(ownSelected.length>2) ownSelected.shift();
    }
    renderBabaUI();
  }
}

function confirmDiscard(){
  if(ownSelected.length<2){
    alert('æ¨ã¦ã‚‹2æšã‚’é¸æŠã—ã¦ãã ã•ã„');
    return;
  }
  const aIdx = ownSelected[0].hi, bIdx = ownSelected[1].hi;
  const hand = babaHands[turnIndex];
  const c1 = hand[aIdx], c2 = hand[bIdx];

  if(!c1 || !c2){
    alert('é¸æŠãŒç„¡åŠ¹ã§ã™');
    ownSelected=[];
    renderBabaUI();
    return;
  }

  if(c1.a===c2.a && c1.b===c2.b && c1.a!==null){
    const ids = [aIdx,bIdx].sort((x,y)=>y-x);
    ids.forEach(ix=>hand.splice(ix,1));
    ownSelected=[];
    renderBabaUI();
    showMatchModal(c1);
    setTimeout(()=> nextTurn(), 500);
  } else {
    alert('é¸æŠã•ã‚ŒãŸ2æšã¯ãƒšã‚¢ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
    ownSelected=[];
    renderBabaUI();
  }
}

/* äººé–“ãŒä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰å¼•ã */
function humanDrawFrom(ti){
  if(ti===turnIndex||disableClicks) return;
  if(!babaHands[ti]||babaHands[ti].length===0) return;

  disableClicks = true;
  const pickIdx = randInt(babaHands[ti].length);
  const drawn = babaHands[ti].splice(pickIdx, 1)[0];
  babaHands[turnIndex].push(drawn);

  // Update UI immediately so drawn card is visible
  renderBabaUI();

  // highlight the drawn card
  const newIdx = babaHands[turnIndex].length - 1;
  const el = document.getElementById(`hand-${turnIndex}-${newIdx}`);
  if(el){
    el.classList.add('drawn-highlight');
    setTimeout(()=> el.classList.remove('drawn-highlight'), 1200);
  }

  // Show info card briefly
  const infoCard = document.getElementById('infoCard');
  if(infoCard){
    infoCard.innerHTML=`
      <div class="card-inner" style="transform: rotateY(180deg);">
        <div class="face back" style="background:#0c2a3d; padding:16px;">
          <div style="font-weight:700;">${playerConfig[ti].name} ã‹ã‚‰å¼•ã„ãŸã‚«ãƒ¼ãƒ‰</div>
          <div style="margin-top:8px; font-size:18px;">${drawn.text || formatEq(drawn.a,drawn.b)}</div>
        </div>
      </div>
    `;
    infoCard.style.display='block';
  }

  setTimeout(()=>{
    if(infoCard) infoCard.style.display='none';
    // After drawing, allow manual discard of pair if exists
    handleAfterDrawForHuman(turnIndex);
  }, 700);
}

/* å¼•ã„ãŸå¾Œã®å‡¦ç†ï¼ˆäººé–“ç”¨ï¼‰ï¼šãƒšã‚¢ãŒã‚ã‚‹ãªã‚‰æ¨ã¦é¸æŠUIã‚’è¡¨ç¤º */
function handleAfterDrawForHuman(playerIndex){
  disableClicks = false;
  const hand = babaHands[playerIndex];
  if(!hand || hand.length === 0){ nextTurn(); return; }
  const pairs = findAllPairsIndices(hand);
  if(pairs.length === 0){
    nextTurn();
    return;
  }

  // There are pairs -> show discard choice UI with timer
  selectablePairs = pairs; // store available pairs as index pairs
  showDiscardChoiceUIForPlayer(playerIndex, pairs);
}

/* CPUãŒå¼•ã„ãŸå¾Œã¯è‡ªå‹•åˆ¤å®šï¼ˆæ—¢ã«å®Ÿè£…ï¼‰ */
async function cpuPlayBaba(){
  const cpu = playerConfig[turnIndex];
  if(!cpu) { nextTurn(); return; }
  const param = getCpuParams(cpu.strength || selectedCPUStrength);
  await new Promise(r=>setTimeout(r,param.delay));
  if(disableClicks) return;

  // ç›¸æ‰‹ã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆæ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é †ã«ï¼‰
  let playersCount = players;
  let targetIdx = (turnIndex+1)%playersCount;
  let cnt = 0;
  while((!babaHands[targetIdx] || babaHands[targetIdx].length===0) && cnt < playersCount){
    targetIdx = (targetIdx+1)%playersCount; cnt++;
  }
  if(!babaHands[targetIdx] || babaHands[targetIdx].length===0){
    nextTurn();
    return;
  }
  const pick = randInt(babaHands[targetIdx].length);
  const drawn = babaHands[targetIdx].splice(pick,1)[0];
  babaHands[turnIndex].push(drawn);

  renderBabaUI();

  showCpuCard(drawn);
  await waitCpuStop();

  // CPU: è‡ªå‹•ã§ãƒšã‚¢ãŒã‚ã‚Œã°æ¨ã¦ã‚‹ï¼ˆæ—¢å­˜ã®è‡ªå‹•å‡¦ç†ï¼‰
  const pair = findFirstPairInHand(babaHands[turnIndex]);
  if(pair){
    const ids=[pair.i,pair.j].sort((a,b)=>b-a);
    const c1=babaHands[turnIndex][ids[0]];
    ids.forEach(ix=>babaHands[turnIndex].splice(ix,1));
    showMatchModal(c1);
  }
  nextTurn();
}

/* ãƒšã‚¢æ¤œå‡ºï¼ˆæ‰‹æœ­å†…ã®æœ€åˆã®ãƒšã‚¢ã‚’è¿”ã™ï¼‰ */
function findFirstPairInHand(h){
  for(let i=0;i<h.length;i++){
    for(let j=i+1;j<h.length;j++){
      if(h[i].a!==null && h[i].a===h[j].a && h[i].b===h[j].b) return {i,j,a:h[i].a,b:h[i].b};
    }
  }
  return null;
}

/* æ‰‹æœ­å†…ã®ã™ã¹ã¦ã®ãƒšã‚¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚¹ãƒˆã‚’è¿”ã™ï¼ˆ[[i,j],[k,l],...]ï¼‰ */
function findAllPairsIndices(h){
  const pairs = [];
  const used = new Set();
  for(let i=0;i<h.length;i++){
    if(used.has(i)) continue;
    for(let j=i+1;j<h.length;j++){
      if(used.has(j)) continue;
      if(h[i].a!==null && h[i].a===h[j].a && h[i].b===h[j].b){
        pairs.push([i,j]);
        used.add(i); used.add(j);
        break;
      }
    }
  }
  return pairs;
}

/* æ¨ã¦UIã‚’è¡¨ç¤ºï¼ˆäººé–“å‘ã‘ï¼‰ */
function showDiscardChoiceUIForPlayer(playerIndex, pairs){
  if(!discardUI) return;
  discardUI.style.display = 'flex';
  let timer = 5;
  discardTimerEl.textContent = timer;
  if(discardInterval) { clearInterval(discardInterval); discardInterval = null; }
  discardInterval = setInterval(()=>{
    timer--;
    discardTimerEl.textContent = timer;
    if(timer <= 0){
      clearInterval(discardInterval);
      discardInterval = null;
      hideDiscardChoiceUI();
      nextTurn();
    }
  },1000);
}

/* hide */
function hideDiscardChoiceUI(){
  if(!discardUI) return;
  discardUI.style.display = 'none';
  if(discardInterval) { clearInterval(discardInterval); discardInterval = null; }
}

/* enable discard mode (highlight pairs for human to click) */
function enableDiscardModeForPlayer(playerIndex){
  const hand = babaHands[playerIndex];
  const pairs = selectablePairs.slice(); // [[i,j],...]
  if(!pairs || pairs.length === 0) {
    nextTurn();
    return;
  }
  discardMode = true;
  // highlight pair cards (by DOM id)
  pairs.forEach(pair => {
    pair.forEach(idx => {
      const el = document.getElementById(`hand-${playerIndex}-${idx}`);
      if(el) el.classList.add('pair-highlight');
    });
  });
}

/* end discard mode (clear highlights) */
function endDiscardMode(){
  discardMode = false;
  const els = document.querySelectorAll('.hand-card.pair-highlight');
  els.forEach(e=>e.classList.remove('pair-highlight'));
  selectablePairs = [];
}

/* discard pair from player's hand by index pair [i,j] */
function discardPairFromHand(playerIndex, pair){
  const hand = babaHands[playerIndex];
  const ids = pair.slice().sort((a,b)=>b-a);
  const removedCards = [];
  ids.forEach(ix=>{
    if(typeof ix === 'number' && ix >=0 && ix < hand.length){
      removedCards.push(hand.splice(ix,1)[0]);
    }
  });
  renderBabaUI();
  if(removedCards.length>0) showMatchModal(removedCards[0]);
}

/* ===== Match / Graph / Result å…±é€š ===== */
function showMatchModal(card){
  if(!matchModal) return;
  matchModal.style.display='flex';
  matchModal.graphCard = card;
  document.getElementById('matchTitle').textContent = 'ãƒšã‚¢æˆç«‹: ' + formatEq(card.a, card.b);
  showMatchTab('formula');
}
function closeMatchModal(){ if(matchModal) matchModal.style.display='none'; }
function showMatchTab(tab){
  if(!matchContent || !matchModal.graphCard) return;
  let c = matchModal.graphCard;
  if(tab==='formula'){
    matchContent.innerHTML = `<span style="font-weight:700;font-size:20px;">${formatEq(c.a, c.b)}</span>`;
  }else if(tab==='table'){
    matchContent.innerHTML = makeTableHTML(c.a, c.b);
  }else if(tab==='graph'){
    matchContent.innerHTML = '<canvas id="matchGraphCanvas" width="400" height="260" style="width:100%; height:220px; background:#fff; margin-top:10px;"></canvas>';
    const ctx = document.getElementById('matchGraphCanvas').getContext('2d');
    const w=400, h=260, cx=w/2, cy=h/2, UNIT=40;
    ctx.fillStyle='#fff';ctx.fillRect(0,0,w,h);
    ctx.save();ctx.translate(cx,cy);
    ctx.strokeStyle='#eee';ctx.lineWidth=1;
    for(let i=-4;i<=4;i++){
      ctx.beginPath();ctx.moveTo(i*UNIT,-h/2);ctx.lineTo(i*UNIT,h/2);ctx.stroke();
      ctx.beginPath();ctx.moveTo(-w/2,i*UNIT);ctx.lineTo(w/2,i*UNIT);ctx.stroke();
    }
    ctx.strokeStyle='#1976d2';ctx.lineWidth=3;ctx.beginPath();
    let started=false;
    for(let px= -w/2;px < w/2;px+=2){
      const gx=px/UNIT;const gy=c.a*gx+c.b;const py=-gy*UNIT;
      if(!started){ctx.moveTo(px,py);started=true;}
      else{ctx.lineTo(px,py);}
    }
    ctx.stroke();ctx.restore();
  }
}

/* ===== Result / Home / Utilities ===== */
function openResult(winList, pts, loser){
  if(!resultModal) return;
  resultModal.style.display='flex';
  if(resultScores){
    let txt = '';
    if(winList && loser){ txt = 'å‹è€…: '+winList.join('ãƒ»')+', æ•—è€…: '+loser; }
    else{ txt = scores.map((s,i)=>`${playerConfig[i].name}: ${s}ç‚¹`).join('<br>'); }
    resultScores.innerHTML = txt;
  }
  usedFunctionsList.innerHTML=[...usedFunctionsSet].map(str=>
    `<span style="display:inline-block;padding:4px 10px;margin:2px;background:#eee;color:#333;border-radius:8px;font-size:15px;">${formatEq(...str.split(',').map(Number))}</span>`
  ).join('');
}
function closeResult(){ if(resultModal) resultModal.style.display='none'; }
function goHome(){ if(gameContainer) gameContainer.style.display='none'; if(homeScreen) homeScreen.style.display='flex'; if(cardArea) cardArea.innerHTML=''; if(learnedDiv) learnedDiv.innerHTML=''; }
function updateTurnDisplay(){ if(!turnBadge) return; if(playerConfig && playerConfig[turnIndex]) turnBadge.textContent = playerConfig[turnIndex].name; else turnBadge.textContent = ''; }
function startTurnTimer(){ stopTurnTimer(); turnTimer = setTimeout(()=>{},999999); }
function stopTurnTimer(){ if(turnTimer) clearTimeout(turnTimer); turnTimer = null; }

/* ===== Graph functions (unchanged) ===== */
function showGraphLarge(card){
  if(!graphModal || !graphCanvas) return;
  graphModal.style.display='flex';
  const title = document.getElementById('graphTitle');
  if(title) title.textContent = `ã‚°ãƒ©ãƒ•: ${formatEq(card.a, card.b)}`;
  graphScale = 1;
  graphModal.graphCard = card;
  drawGraph(card);
}
function drawGraph(card){
  if(!graphCtx) return;
  const w=graphCanvas.width, h=graphCanvas.height;
  const xCenter=w/2, yCenter=h/2;
  const UNIT_PX = 40 * graphScale;
  graphCtx.fillStyle='#fff';
  graphCtx.fillRect(0,0,w,h);
  graphCtx.save();
  graphCtx.translate(xCenter, yCenter);
  graphCtx.strokeStyle='#eee';
  graphCtx.lineWidth=1;
  const xMax = Math.ceil(w/2 / UNIT_PX);
  const yMax = Math.ceil(h/2 / UNIT_PX);
  for(let i=1; i<=xMax; i++){
    const px = i * UNIT_PX;
    graphCtx.beginPath();
    graphCtx.moveTo(px, -h/2);
    graphCtx.lineTo(px, h/2);
    graphCtx.stroke();
    graphCtx.beginPath();
    graphCtx.moveTo(-px, -h/2);
    graphCtx.lineTo(-px, h/2);
    graphCtx.stroke();
  }
  for(let i=1; i<=yMax; i++){
    const py = i * UNIT_PX;
    graphCtx.beginPath();
    graphCtx.moveTo(-w/2, py);
    graphCtx.lineTo(w/2, py);
    graphCtx.stroke();
    graphCtx.beginPath();
    graphCtx.moveTo(-w/2, -py);
    graphCtx.lineTo(w/2, -py);
    graphCtx.stroke();
  }
  graphCtx.strokeStyle='#222'; graphCtx.lineWidth=2.5;
  graphCtx.beginPath(); graphCtx.moveTo(-w/2,0); graphCtx.lineTo(w/2,0); graphCtx.stroke();
  graphCtx.beginPath(); graphCtx.moveTo(0,-h/2); graphCtx.lineTo(0,h/2); graphCtx.stroke();
  if(card.a){
    graphCtx.strokeStyle='#1976d2';
    graphCtx.lineWidth=3;
    graphCtx.beginPath();
    let started = false;
    for(let px=-w/2;px<w/2;px+=2){
      const gx = px/UNIT_PX;
      const gy = card.a*gx+card.b;
      const py = -gy*UNIT_PX;
      if(!started){
        graphCtx.moveTo(px, py);
        started = true;
      }else{
        graphCtx.lineTo(px, py);
      }
    }
    graphCtx.stroke();
  }
  graphCtx.restore();
}
function closeGraph(){ if(graphModal) graphModal.style.display='none'; }
function zoomGraph(s){ graphScale *= s; if(matchModal.style.display==='flex'){ if(matchModal.graphCard) drawGraph(matchModal.graphCard); }else if(graphModal.style.display==='flex'){ if(graphModal.graphCard) drawGraph(graphModal.graphCard); } }

/* ===== å¿…è¦ãªè£œåŠ©é–¢æ•°: endMemoryGame ã¨ nextTurn ===== */
function endMemoryGame(){
  // ã‚·ãƒ³ãƒ—ãƒ«ã«çµ‚äº† â†’ ãƒªã‚¶ãƒ«ãƒˆè¡¨ç¤º
  stopTurnTimer();
  // æ±ºç€ã‚’åˆ¤å®šï¼ˆç‚¹æ•°æœ€å¤§è€…ï¼‰
  const maxScore = Math.max(...scores);
  const winners = [];
  scores.forEach((sc,i)=>{ if(sc===maxScore) winners.push(playerConfig[i].name); });
  openResult(winners, 0, null);
}

function nextTurn(){
  // Advance turn, handle empty hands etc.
  // For safety, clear discard mode if active
  endDiscardMode();

  // Find next player who still participates (for Babanuki, skip empty hands)
  let attempts = 0;
  let nextIndex = (turnIndex + 1) % players;
  while(attempts < players){
    if(mode === 'babanuki'){
      if(babaHands[nextIndex] && babaHands[nextIndex].length > 0) break;
    } else {
      // memory mode: all players are always valid
      break;
    }
    nextIndex = (nextIndex + 1) % players;
    attempts++;
  }
  turnIndex = nextIndex % players;

  updateTurnDisplay();
  // Re-render UI for baba
  if(mode === 'babanuki') renderBabaUI();
  if(mode === 'memory') {
    // memory uses card grid; ensure it's visible
    // renderMemoryTable(); // avoid resetting state; not necessary here
  }

  stopTurnTimer();
  startTurnTimer();

  // If CPU's turn, schedule their move
  if(playerConfig[turnIndex] && playerConfig[turnIndex].type === "cpu"){
    if(mode === "babanuki"){
      setTimeout(cpuPlayBaba, 600);
    } else if(mode === "memory"){
      setTimeout(cpuPlayMemory, 600);
    }
  }
}

/* ===== ç°¡æ˜“åˆæœŸçŠ¶æ…‹ï¼ˆã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰ ===== */
playerConfig = [
  {name:'P1', type:'human', strength:'weak'},
  {name:'P2', type:'cpu', strength:'normal'}
];
updateTurnDisplay();

</script>
</body>
</html>
